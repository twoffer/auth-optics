# Vulnerability Mode Reference - Authorization Endpoint
## Detailed Specifications for Authorization Vulnerabilities

> *"The authorization endpoint is where users say 'yes' and attackers say 'please?'"*

---

## Document Information

| Property | Value |
|----------|-------|
| **Document Type** | Detailed Vulnerability Specifications |
| **Category** | Authorization Endpoint Vulnerabilities |
| **Toggles Covered** | 9 authorization-related vulnerabilities |
| **Target** | Claude Code (implementation) |
| **Part** | 2 of 4 |

---

## Authorization Endpoint Vulnerabilities

### Toggle 1: DISABLE_PKCE

**Full Name**: Disable Proof Key for Code Exchange

**Category**: Authorization Endpoint

**Attack Name**: Authorization Code Interception

**Severity**: üî¥ Critical

**Spec References**:
- RFC 7636 (PKCE)
- OAuth 2.0 Security BCP Section 4.8
- OAuth 2.1 (PKCE Required)

**Related Specification Documents**:
- `pkce-implementation.md` - Complete PKCE implementation guide
- `authorization-code-flow-with-pkce.md` - Flow with PKCE
- `oauth2-oidc-threat-model.md` Section 3.2 - Code interception threats

**What This Vulnerability Does**:

Removes Proof Key for Code Exchange (PKCE) from the authorization code flow. Authorization requests do not include `code_challenge`, and token requests do not include `code_verifier`. This removes the cryptographic binding between the authorization request and token exchange.

**Attack Scenario**:

```
1. Victim initiates authorization:
   GET /authorize?response_type=code&client_id=public-app&...
   (No code_challenge - vulnerability active)

2. Victim authenticates and authorizes

3. Authorization server redirects:
   http://localhost:3000/callback?code=AUTH_CODE_123

4. ATTACKER intercepts authorization code via:
   - Network sniffing (if HTTP used)
   - Malware on victim's device
   - Custom URI scheme hijacking (mobile)
   - Browser history access
   - Referer header leakage

5. ATTACKER exchanges intercepted code:
   POST /token
   grant_type=authorization_code
   code=AUTH_CODE_123
   client_id=public-app
   redirect_uri=http://localhost:3000/callback
   (No code_verifier required)

6. Authorization server validates:
   ‚úì Code valid
   ‚úì Client ID matches
   ‚úì Redirect URI matches
   ‚úì No PKCE verification (disabled)
   
7. ATTACKER receives:
   {
     "access_token": "VICTIM_ACCESS_TOKEN",
     "refresh_token": "VICTIM_REFRESH_TOKEN",
     "id_token": "VICTIM_ID_TOKEN"
   }

8. ATTACKER now has complete access to victim's account
```

**Demonstration Steps (In Tool)**:

1. **Enable `DISABLE_PKCE` toggle**
2. **Select client**: `spa-client` (normally requires PKCE)
3. **Select user**: `alice`
4. **Start Authorization Code Flow**
5. **Observe authorization request**:
   - Show URL without `code_challenge` parameter
   - Highlight missing PKCE
6. **Complete authentication** (user login simulation)
7. **Capture authorization code**
8. **Simulate attacker**: Show "attacker" component intercepting code
9. **Attacker token exchange**: Show attacker successfully exchanging code
10. **Compare with secure mode**:
    - Disable `DISABLE_PKCE`
    - Repeat flow with PKCE
    - Show attacker exchange fails without `code_verifier`

**Educational Value**:

Users learn:
- Why PKCE is critical for public clients (no client secret)
- How authorization codes can be intercepted
- Why OAuth 2.1 mandates PKCE for ALL clients
- The cryptographic binding PKCE provides
- Why confidential clients should also use PKCE

**Impact**:

- **Severity**: Complete account takeover
- **Exploitability**: High (many interception vectors)
- **Scope**: Any public client without PKCE
- **Real-World**: CVE-2019-16156 (OAuth SDK vulnerability)

**Mitigation**:

1. **Always use PKCE** for authorization code flow
2. **Use S256 method** (not plain)
3. **Generate high-entropy code_verifier** (43-128 characters)
4. **Store verifier securely** until token exchange
5. **Enforce PKCE** at authorization server level

**UI Indicators**:

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚ö†Ô∏è  PKCE DISABLED  ‚ö†Ô∏è                                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Authorization codes can be intercepted and used by      ‚ïë
‚ïë  attackers without verification.                         ‚ïë
‚ïë                                                           ‚ïë
‚ïë  Attack: Code Interception ‚Üí Account Takeover            ‚ïë
‚ïë  Mitigation: Enable PKCE (OAuth 2.1 requirement)         ‚ïë
‚ïë                                                           ‚ïë
‚ïë  [Why is this dangerous?] [Enable PKCE] [Learn More]     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

**Code Implementation**:

```javascript
function buildAuthorizationRequest(config, vulnerabilities) {
  const params = {
    response_type: 'code',
    client_id: config.clientId,
    redirect_uri: config.redirectUri,
    scope: config.scope,
    state: generateState() // State still included
  };
  
  // PKCE logic (skipped if DISABLE_PKCE is true)
  if (!vulnerabilities.DISABLE_PKCE) {
    const codeVerifier = generateCodeVerifier(); // 43-128 chars
    const codeChallenge = await generateCodeChallenge(codeVerifier, 'S256');
    
    params.code_challenge = codeChallenge;
    params.code_challenge_method = 'S256';
    
    // Store for token exchange
    sessionStorage.setItem('pkce_verifier', codeVerifier);
  } else {
    console.warn('üö® PKCE DISABLED - Authorization codes vulnerable!');
  }
  
  return buildURL(authorizationEndpoint, params);
}

function exchangeCodeForTokens(code, config, vulnerabilities) {
  const body = {
    grant_type: 'authorization_code',
    code: code,
    client_id: config.clientId,
    redirect_uri: config.redirectUri
  };
  
  // Add code_verifier if PKCE not disabled
  if (!vulnerabilities.DISABLE_PKCE) {
    const verifier = sessionStorage.getItem('pkce_verifier');
    if (!verifier) {
      throw new Error('PKCE verifier not found');
    }
    body.code_verifier = verifier;
    sessionStorage.removeItem('pkce_verifier'); // Single use
  }
  
  return fetch(tokenEndpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams(body)
  });
}
```

---

### Toggle 2: SKIP_STATE_VALIDATION

**Full Name**: Skip State Parameter Validation

**Category**: Authorization Endpoint

**Attack Name**: Cross-Site Request Forgery (CSRF)

**Severity**: üî¥ Critical

**Spec References**:
- RFC 6749 Section 10.12
- OAuth 2.0 Security BCP Section 4.7
- OAuth 2.1 Section 4.7

**Related Specification Documents**:
- `state-parameter-and-csrf.md` - Complete state parameter guide
- `oauth2-oidc-threat-model.md` Section 3.1 - CSRF threats

**What This Vulnerability Does**:

Client skips validation of the `state` parameter in the authorization response. The client does not verify that the returned `state` matches the value sent in the authorization request. This removes CSRF protection from the authorization flow.

**Attack Scenario**:

```
1. ATTACKER initiates authorization on their own device:
   GET /authorize?response_type=code&client_id=app&state=ATTACKER_STATE

2. ATTACKER receives authorization code at their redirect_uri

3. ATTACKER crafts malicious link with their authorization:
   http://victim-app.com/callback?code=ATTACKER_CODE&state=ATTACKER_STATE

4. ATTACKER tricks VICTIM into clicking link (phishing, social engineering)

5. VICTIM's browser loads:
   http://victim-app.com/callback?code=ATTACKER_CODE&state=ATTACKER_STATE

6. VICTIM's client (with SKIP_STATE_VALIDATION):
   ‚úó Does not validate state parameter
   ‚úì Proceeds to exchange code for tokens

7. VICTIM's client exchanges ATTACKER's code:
   POST /token
   code=ATTACKER_CODE
   (This is ATTACKER's authorization)

8. VICTIM's session now linked to ATTACKER's authorization

9. Consequences:
   - VICTIM's actions benefit ATTACKER's account
   - Data uploaded by VICTIM goes to ATTACKER
   - Payments made by VICTIM charged to ATTACKER's account
   - Session fixation attack successful
```

**Demonstration Steps (In Tool)**:

1. **Enable `SKIP_STATE_VALIDATION` toggle**
2. **Start authorization flow**
3. **Show state generation**: `state=abc123xyz`
4. **Complete authorization**
5. **Simulate attack**:
   - Tool shows authorization response with DIFFERENT state
   - `code=AUTH_CODE&state=WRONG_STATE`
6. **Show client processing**:
   - Client skips state validation
   - Client accepts response
   - Client exchanges code
7. **Highlight vulnerability**: Client didn't notice state mismatch
8. **Compare with secure mode**:
   - Disable `SKIP_STATE_VALIDATION`
   - Repeat with mismatched state
   - Show client rejecting response

**Educational Value**:

- Understanding CSRF in OAuth2 context
- Importance of state parameter
- Session fixation attacks
- Why cryptographically random state is important

**Impact**:

- **Severity**: Account linking, data leakage, session fixation
- **Exploitability**: Medium (requires social engineering)
- **Scope**: Any client not validating state
- **Real-World**: Multiple OAuth implementations vulnerable

**Mitigation**:

1. **Always include state parameter** in authorization request
2. **Generate cryptographically random state** (128+ bits)
3. **Store state** before redirect (session, cookies)
4. **Validate state matches** in callback
5. **Reject response** if state doesn't match

**UI Indicators**:

```
‚ö†Ô∏è STATE VALIDATION DISABLED
CSRF attacks possible - authorization responses not verified
[Enable State Validation] [Learn about CSRF]
```

**Code Implementation**:

```javascript
function buildAuthorizationRequest(config, vulnerabilities) {
  // Always generate state (even if not validated)
  const state = generateRandomString(32); // 128 bits minimum
  
  if (!vulnerabilities.SKIP_STATE_VALIDATION) {
    // Store for validation
    sessionStorage.setItem('oauth_state', state);
    sessionStorage.setItem('oauth_state_timestamp', Date.now());
  } else {
    console.warn('üö® STATE VALIDATION DISABLED - CSRF vulnerable!');
  }
  
  return {
    // ... other params
    state: state
  };
}

function handleAuthorizationResponse(params, vulnerabilities) {
  const receivedState = params.get('state');
  
  if (!vulnerabilities.SKIP_STATE_VALIDATION) {
    const expectedState = sessionStorage.getItem('oauth_state');
    const timestamp = sessionStorage.getItem('oauth_state_timestamp');
    
    // Clear state (single use)
    sessionStorage.removeItem('oauth_state');
    sessionStorage.removeItem('oauth_state_timestamp');
    
    // Validate state
    if (!expectedState) {
      throw new Error('No state found - possible CSRF');
    }
    
    if (receivedState !== expectedState) {
      throw new Error('State mismatch - possible CSRF attack');
    }
    
    // Check state age (optional but recommended)
    const age = Date.now() - parseInt(timestamp);
    if (age > 600000) { // 10 minutes
      throw new Error('State expired');
    }
  }
  
  // Proceed with code exchange
  const code = params.get('code');
  return exchangeCodeForTokens(code);
}
```

---

### Toggle 3: PREDICTABLE_STATE

**Full Name**: Use Predictable State Parameter

**Category**: Authorization Endpoint

**Attack Name**: CSRF with State Guessing

**Severity**: üü† High

**Spec References**:
- OAuth 2.0 Security BCP Section 4.7.1
- RFC 6749 Section 10.10 (random values)

**Related Specification Documents**:
- `state-parameter-and-csrf.md` Section 4 - State entropy requirements

**What This Vulnerability Does**:

Uses predictable or low-entropy state values (sequential numbers, timestamps, weak random). While state validation occurs, attackers can guess or predict the state value, bypassing CSRF protection.

**Attack Scenario**:

```
1. Client uses predictable state: timestamp or sequential ID
   state=1703001234 (Unix timestamp)
   OR state=user_123_session_456 (predictable pattern)

2. ATTACKER observes state pattern through:
   - Multiple authorization attempts
   - Public OAuth logs/debug info
   - Analyzing application behavior

3. ATTACKER predicts next state value:
   If timestamps: state=1703001235 (current time)
   If sequential: state=user_123_session_457

4. ATTACKER crafts CSRF attack with predicted state

5. If prediction correct, attack succeeds despite validation
```

**Demonstration Steps (In Tool)**:

1. **Enable `PREDICTABLE_STATE` toggle**
2. **Show state generation**:
   - Tool generates: `state=1703001234` (timestamp)
   - Or: `state=session_001` (sequential)
3. **Simulate multiple requests**: Show predictable pattern
4. **Show attacker analysis**: Attacker identifies pattern
5. **Show prediction**: Attacker predicts next state
6. **Show successful CSRF**: Predicted state matches, attack succeeds
7. **Compare with strong state**:
   - Disable toggle
   - Show cryptographically random state
   - Show prediction impossible

**Educational Value**:

- Importance of cryptographic randomness
- Why entropy matters for security tokens
- How attackers analyze predictable values
- Proper random number generation

**Impact**:

- **Severity**: CSRF protection bypassed
- **Exploitability**: Medium (requires pattern analysis)
- **Scope**: Clients using weak state generation

**Mitigation**:

```javascript
// WRONG - Predictable
const state = Date.now().toString(); // ‚ùå

// WRONG - Low entropy
const state = Math.random().toString(); // ‚ùå

// CORRECT - Cryptographically random
const state = crypto.randomBytes(32).toString('base64url'); // ‚úì
// OR
const array = new Uint8Array(32);
crypto.getRandomValues(array);
const state = base64url(array); // ‚úì
```

**Code Implementation**:

```javascript
function generateState(vulnerabilities) {
  if (vulnerabilities.PREDICTABLE_STATE) {
    // Intentionally weak for demonstration
    console.warn('üö® PREDICTABLE STATE - Weak CSRF protection!');
    return Date.now().toString(); // Timestamp - predictable
  }
  
  // Secure state generation
  const array = new Uint8Array(32); // 256 bits
  crypto.getRandomValues(array);
  return base64urlEncode(array);
}
```

---

### Toggle 4: LAX_REDIRECT_URI

**Full Name**: Lax Redirect URI Validation

**Category**: Authorization Endpoint

**Attack Name**: Open Redirect / Authorization Code Theft

**Severity**: üî¥ Critical

**Spec References**:
- RFC 6749 Section 3.1.2
- OAuth 2.0 Security BCP Section 4.1
- OAuth 2.0 Security BCP Section 4.1.3

**Related Specification Documents**:
- `redirect-uri-validation.md` - Complete redirect URI validation guide
- `oauth2-oidc-threat-model.md` Section 3.3 - Open redirect threats

**What This Vulnerability Does**:

Uses overly permissive redirect URI matching, such as:
- Wildcard patterns (`http://example.com/*`)
- Subdomain wildcards (`https://*.example.com/callback`)
- Missing path validation (`http://example.com` matches any path)
- Pattern matching instead of exact matching

**Attack Scenario**:

```
Client Registered Redirect URIs:
- http://localhost:3000/*           (wildcard - VULNERABLE)
- http://attacker.example.com/steal (attacker domain registered)

Attack:
1. ATTACKER crafts malicious authorization URL:
   /authorize?response_type=code&client_id=vulnerable-client
              &redirect_uri=http://attacker.example.com/steal
              &state=xyz

2. VICTIM clicks link, authenticates

3. Authorization server checks redirect_uri:
   Requested: http://attacker.example.com/steal
   Registered: http://attacker.example.com/steal
   Result: ‚úì MATCH (because it's explicitly registered)

4. Authorization code sent to attacker:
   http://attacker.example.com/steal?code=AUTH_CODE_123&state=xyz

5. ATTACKER captures code, exchanges for tokens

Variant - Wildcard Exploitation:
1. Registered: http://localhost:3000/*
2. ATTACKER requests: http://localhost:3000/../attacker.com/steal
   OR: http://localhost:3000/redirect?url=http://attacker.com
3. If client has open redirect on any path, attack succeeds
```

**Demonstration Steps (In Tool)**:

1. **Enable `LAX_REDIRECT_URI` toggle**
2. **Show registered URIs**:
   - `http://localhost:3000/*` (wildcard)
   - Display vulnerability warning
3. **Attacker crafts URL**:
   - Show authorization URL with attacker's redirect_uri
4. **Show authorization server accepting**:
   - Wildcard matches attacker URI
   - Code redirected to attacker
5. **Compare with exact matching**:
   - Disable toggle
   - Same attack attempt
   - Show rejection: `invalid_redirect_uri`

**Educational Value**:

- Why exact matching is critical
- Dangers of wildcard redirect URIs
- How open redirects are exploited
- Proper redirect URI registration

**Impact**:

- **Severity**: Complete authorization code theft
- **Exploitability**: High (if wildcards used)
- **Scope**: Any client with loose URI validation
- **Real-World**: Multiple OAuth implementations vulnerable

**Mitigation**:

1. **Use exact matching** only
2. **Register complete, specific URIs**
3. **No wildcards** in production
4. **No pattern matching**
5. **Validate scheme, host, port, path exactly**

**Code Implementation**:

```javascript
function validateRedirectUri(requestedUri, registeredUris, vulnerabilities) {
  if (vulnerabilities.LAX_REDIRECT_URI) {
    // Vulnerable: Allow pattern matching or wildcards
    console.warn('üö® LAX REDIRECT URI - Open redirect possible!');
    
    return registeredUris.some(registered => {
      // Wildcard matching (DANGEROUS)
      if (registered.endsWith('/*')) {
        const base = registered.slice(0, -2);
        return requestedUri.startsWith(base);
      }
      return requestedUri === registered;
    });
  }
  
  // Secure: Exact matching only
  return registeredUris.includes(requestedUri);
}
```

---

### Toggle 5: PATTERN_MATCHING_URI

**Full Name**: Pattern-Based Redirect URI Matching

**Category**: Authorization Endpoint

**Attack Name**: Redirect URI Bypass

**Severity**: üü† High

**Spec References**:
- OAuth 2.0 Security BCP Section 4.1.2

**Related Specification Documents**:
- `redirect-uri-validation.md` Section 3 - Exact vs pattern matching

**What This Vulnerability Does**:

Uses regex or pattern matching for redirect URI validation instead of exact string matching. Allows bypasses through URL encoding, path traversal, or pattern exploitation.

**Attack Scenario**:

```
Registered: http://example.com/callback
Pattern Matching (vulnerable): /^http:\/\/example\.com\/callback/

Attack vectors:
1. URL encoding bypass:
   http://example.com/callback%2f%2fattacker.com
   Pattern matches, but resolves to attacker domain

2. Path traversal:
   http://example.com/callback/../../../attacker.com
   Pattern matches prefix, but navigates to attacker

3. Fragment/Query confusion:
   http://example.com/callback#@attacker.com
   Pattern matches, but browser may interpret differently

4. Domain confusion:
   http://example.com.attacker.com/callback
   Pattern matches "example.com/callback" substring
```

**Demonstration Steps (In Tool)**:

1. **Enable `PATTERN_MATCHING_URI`**
2. **Show registered URI**: `http://localhost:3000/callback`
3. **Show pattern**: `/^http:\/\/localhost:3000\/callback/`
4. **Attempt bypass**:
   - Try: `http://localhost:3000/callback/../attacker`
   - Show: Pattern matches
   - Show: Browser resolves to different location
5. **Compare with exact matching**:
   - Disable toggle
   - Same bypass attempt
   - Show: Exact match fails, attack prevented

**Educational Value**:

- Why string comparison is better than regex
- URL parsing complexity
- Character encoding issues
- Browser URL resolution quirks

**Mitigation**:

```javascript
// WRONG - Pattern matching
function validateUri(requested, registered) {
  const pattern = new RegExp(`^${registered}`);
  return pattern.test(requested); // ‚ùå Vulnerable
}

// CORRECT - Exact matching
function validateUri(requested, registered) {
  return requested === registered; // ‚úì Secure
}

// CORRECT - Parse and compare components
function validateUri(requested, registered) {
  const reqUrl = new URL(requested);
  const regUrl = new URL(registered);
  
  return reqUrl.protocol === regUrl.protocol &&
         reqUrl.host === regUrl.host &&
         reqUrl.pathname === regUrl.pathname &&
         reqUrl.search === regUrl.search;
}
```

---

### Toggle 6: ALLOW_IFRAME

**Full Name**: Allow Authorization in iFrame

**Category**: Authorization Endpoint

**Attack Name**: Clickjacking / UI Redressing

**Severity**: üü° Medium

**Spec References**:
- RFC 6749 Section 10.13
- OAuth 2.0 Security BCP Section 4.11

**Related Specification Documents**:
- `security-best-current-practice.md` Section 8 - Clickjacking protection

**What This Vulnerability Does**:

Allows authorization endpoint to be loaded in an iframe, enabling clickjacking attacks where attacker overlays invisible iframe over legitimate UI elements.

**Attack Scenario**:

```
1. ATTACKER creates malicious page:
   <html>
   <style>
     iframe { position: absolute; opacity: 0.01; z-index: 2; }
     button { position: absolute; z-index: 1; }
   </style>
   <iframe src="https://auth-server.com/authorize?..."></iframe>
   <button>Click here to win prize!</button>
   </html>

2. VICTIM visits attacker's page

3. ATTACKER overlays invisible authorization iframe
   over "Click to win" button

4. VICTIM clicks what looks like prize button

5. VICTIM actually clicks "Authorize" in invisible iframe

6. Authorization granted to attacker without user's knowledge
```

**Demonstration Steps (In Tool)**:

1. **Enable `ALLOW_IFRAME`**
2. **Show authorization page in iframe**
3. **Simulate clickjacking**:
   - Overlay visible fake button
   - Show invisible iframe underneath
   - Demonstrate click confusion
4. **Show mitigation**:
   - Disable toggle
   - Authorization server sends: `X-Frame-Options: DENY`
   - iframe blocked by browser

**Educational Value**:

- Understanding clickjacking attacks
- Browser frame security
- X-Frame-Options and CSP
- Why authorization should never be in iframe

**Mitigation**:

Authorization server should send:
```
X-Frame-Options: DENY
```

OR via Content Security Policy:
```
Content-Security-Policy: frame-ancestors 'none'
```

Client should detect iframe:
```javascript
if (window !== window.top) {
  throw new Error('Authorization cannot occur in iframe');
}
```

---

### Toggle 7: HTTP_AUTHORIZATION_ENDPOINT

**Full Name**: Allow HTTP Authorization Endpoint

**Category**: Authorization Endpoint

**Attack Name**: Network-Level Code Interception

**Severity**: üî¥ Critical

**Spec References**:
- OAuth 2.0 Security BCP Section 4.2
- RFC 6749 Section 3.1 (TLS required)

**Related Specification Documents**:
- `security-best-current-practice.md` Section 2 - TLS requirements

**What This Vulnerability Does**:

Allows authorization requests over unencrypted HTTP instead of requiring HTTPS. All authorization parameters, including codes and state, transmitted in plaintext.

**Attack Scenario**:

```
1. Client initiates authorization over HTTP:
   http://auth-server.com/authorize?... (NO TLS)

2. ATTACKER on network path (coffee shop WiFi, compromised router)
   intercepts HTTP traffic

3. ATTACKER captures:
   - Authorization request (client_id, redirect_uri, state)
   - Authorization response (authorization code)

4. ATTACKER uses intercepted code before victim

5. Combined with DISABLE_PKCE, leads to account takeover
```

**Demonstration Steps (In Tool)**:

1. **Enable `HTTP_AUTHORIZATION_ENDPOINT`**
2. **Show authorization URL**: `http://` instead of `https://`
3. **Simulate network capture**:
   - Show "attacker" capturing HTTP traffic
   - Display intercepted authorization code
4. **Show HTTPS protection**:
   - Disable toggle
   - Show `https://` required
   - Explain TLS encryption prevents interception

**Educational Value**:

- Why HTTPS is mandatory for OAuth2
- Network-level attacks
- TLS/SSL basics
- Certificate validation importance

**Mitigation**:

```javascript
function validateAuthorizationEndpoint(url) {
  const parsed = new URL(url);
  
  // HTTPS required (except localhost for development)
  if (parsed.protocol !== 'https:' && parsed.hostname !== 'localhost') {
    throw new Error('Authorization endpoint must use HTTPS');
  }
}
```

---

### Toggle 8: DISABLE_ISS_CHECK

**Full Name**: Disable Issuer Check

**Category**: Authorization Endpoint

**Attack Name**: Mix-Up Attack / IdP Confusion

**Severity**: üî¥ Critical

**Spec References**:
- RFC 9207 (OAuth 2.0 Authorization Server Issuer Identification)
- OAuth 2.0 Security BCP Section 4.4

**Related Specification Documents**:
- `oauth2-oidc-threat-model.md` Section 5 - Mix-up attacks
- `id-tokens-oidc.md` Section 6 - Issuer validation

**What This Vulnerability Does**:

Client does not validate the `iss` (issuer) parameter or ID token issuer claim. Enables attacks where client uses authorization code or tokens from wrong identity provider.

**Attack Scenario**:

```
Setup:
- Client supports multiple IdPs: HonestIdP.com and EvilIdP.com
- Client has credentials with both

Attack:
1. ATTACKER redirects victim to EvilIdP authorization:
   https://EvilIdP.com/authorize?client_id=legitimate-client...

2. VICTIM authenticates at EvilIdP (attacker-controlled)

3. EvilIdP issues authorization code

4. Client receives code in callback (no iss parameter check)

5. Client exchanges code at HonestIdP (wrong IdP!)
   Client assumes code came from HonestIdP

6. If HonestIdP has vulnerability or accepts invalid codes,
   attacker gains access with their EvilIdP credentials
   mapped to victim's HonestIdP account
```

**Demonstration Steps (In Tool)**:

1. **Enable `DISABLE_ISS_CHECK`**
2. **Setup two IdPs**: Primary and "Evil" IdP
3. **Show authorization from Evil IdP**
4. **Show client accepting code without validation**
5. **Show client attempting token exchange at wrong IdP**
6. **Compare with issuer validation**:
   - Disable toggle
   - Show `iss` parameter in authorization response
   - Show client validating issuer
   - Show rejection of mismatched issuer

**Educational Value**:

- Multi-IdP security challenges
- Importance of issuer identification
- How mix-up attacks work
- Why RFC 9207 was created

**Mitigation**:

```javascript
function handleAuthorizationResponse(params, expectedIssuer) {
  const code = params.get('code');
  const iss = params.get('iss'); // RFC 9207 parameter
  
  // Validate issuer
  if (iss && iss !== expectedIssuer) {
    throw new Error(`Issuer mismatch: expected ${expectedIssuer}, got ${iss}`);
  }
  
  // Also validate in ID token
  const tokens = await exchangeCode(code);
  const idToken = decodeJWT(tokens.id_token);
  
  if (idToken.iss !== expectedIssuer) {
    throw new Error('ID token issuer mismatch');
  }
}
```

---

### Toggle 9: PKCE_DOWNGRADE

**Full Name**: Allow PKCE Downgrade

**Category**: Authorization Endpoint

**Attack Name**: PKCE Downgrade Attack

**Severity**: üü† High

**Spec References**:
- OAuth 2.0 Security BCP Section 4.8.2

**Related Specification Documents**:
- `pkce-implementation.md` Section 7 - Downgrade attacks

**What This Vulnerability Does**:

Client includes PKCE parameters but also accepts responses without requiring PKCE validation. Attacker can strip PKCE parameters, downgrading to vulnerable authorization code flow.

**Attack Scenario**:

```
1. Client initiates authorization WITH PKCE:
   /authorize?code_challenge=E9Melhoa2...&code_challenge_method=S256

2. ATTACKER intercepts authorization request (MITM)

3. ATTACKER strips PKCE parameters:
   /authorize? (no code_challenge)

4. Authorization server issues code (no PKCE binding)

5. ATTACKER intercepts code

6. Client attempts token exchange WITH code_verifier
   But server doesn't require it (no PKCE was used)

7. If client accepts response, downgrade successful
   ATTACKER can use code without verifier
```

**Demonstration Steps (In Tool)**:

1. **Enable `PKCE_DOWNGRADE`**
2. **Start authorization with PKCE**
3. **Simulate MITM stripping PKCE parameters**
4. **Show authorization without PKCE**
5. **Show code issued without binding**
6. **Show client accepting downgraded flow**
7. **Compare with downgrade protection**:
   - Require PKCE confirmation in token response
   - Reject if PKCE not used

**Educational Value**:

- Understanding protocol downgrade attacks
- Importance of consistent security enforcement
- Why both client and server must enforce PKCE
- Defense in depth principles

**Mitigation**:

```javascript
// Client must verify PKCE was used
function exchangeCodeForTokens(code, codeVerifier) {
  const response = await fetch(tokenEndpoint, {
    method: 'POST',
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      code_verifier: codeVerifier // Always include
    })
  });
  
  if (!response.ok) {
    const error = await response.json();
    
    // If error indicates PKCE not used, reject
    if (error.error === 'invalid_request' && 
        error.error_description.includes('PKCE')) {
      throw new Error('PKCE downgrade detected');
    }
  }
  
  return response.json();
}
```

---

## Vulnerability Combinations

### Authorization Endpoint Attack Chains

**Chain 1: Complete Code Interception**

Requires:
- `HTTP_AUTHORIZATION_ENDPOINT` (network interception)
- `DISABLE_PKCE` (code usable without verification)

Result: Authorization code intercepted via network sniffing and successfully exchanged

**Chain 2: Sophisticated Open Redirect**

Requires:
- `LAX_REDIRECT_URI` (wildcard URIs)
- `SKIP_STATE_VALIDATION` (no CSRF protection)

Result: CSRF attack combined with code redirect to attacker

**Chain 3: Multi-IdP Attack**

Requires:
- `DISABLE_ISS_CHECK` (no issuer validation)
- `SKIP_STATE_VALIDATION` (session fixation)

Result: Mix-up attack with session fixation

---

## Document Metadata

| Property | Value |
|----------|-------|
| **Version** | 1.0.0 |
| **Part** | 2 of 4 (Authorization Endpoint) |
| **Toggles Covered** | 9 authorization vulnerabilities |
| **Target** | Claude Code (implementation) |

---

**Next**: See `vulnerability-mode-token.md` for token endpoint and validation vulnerability specifications.
