# Vulnerability Mode Reference - Implementation Guide
## Development, Testing, and Educational Content

> *"The best way to learn security is to break it intentionally, then fix it properly."*

---

## Document Information

| Property | Value |
|----------|-------|
| **Document Type** | Implementation Guide |
| **Purpose** | Practical guidance for implementing vulnerability toggles |
| **Target** | Claude Code, developers implementing the tool |
| **Part** | 4 of 4 (Implementation & Integration) |

---

## 1. Implementation Architecture

### 1.1 Configuration Management

**VulnerabilityConfig Object**:

```typescript
interface VulnerabilityConfig {
  // Master toggle
  enabled: boolean;
  
  // Individual vulnerability toggles
  toggles: {
    // Authorization Endpoint (9 toggles)
    DISABLE_PKCE: boolean;
    SKIP_STATE_VALIDATION: boolean;
    PREDICTABLE_STATE: boolean;
    LAX_REDIRECT_URI: boolean;
    PATTERN_MATCHING_URI: boolean;
    ALLOW_IFRAME: boolean;
    HTTP_AUTHORIZATION_ENDPOINT: boolean;
    DISABLE_ISS_CHECK: boolean;
    PKCE_DOWNGRADE: boolean;
    
    // Token Endpoint (5 toggles)
    SKIP_CLIENT_AUTH: boolean;
    WEAK_CLIENT_SECRET: boolean;
    REUSABLE_AUTH_CODE: boolean;
    ALLOW_SCOPE_ESCALATION: boolean;
    HTTP_TOKEN_ENDPOINT: boolean;
    
    // Token Validation (9 toggles)
    SKIP_JWT_VERIFICATION: boolean;
    ACCEPT_NONE_ALGORITHM: boolean;
    FLEXIBLE_JWT_ALGORITHM: boolean;
    SKIP_EXPIRATION_CHECK: boolean;
    SKIP_AUD_CHECK: boolean;
    SKIP_ISS_CHECK: boolean;
    SKIP_NONCE: boolean;
    SKIP_AT_HASH: boolean;
    SKIP_HASH_VALIDATION: boolean;
    
    // Token Storage (3 toggles)
    LOCALSTORAGE_TOKENS: boolean;
    INSECURE_REFRESH_STORAGE: boolean;
    ALLOW_TOKEN_EXPORT: boolean;
    
    // Token Transmission (3 toggles)
    ALLOW_TOKEN_IN_URL: boolean;
    HTTP_RESOURCE_SERVER: boolean;
    ALLOW_FRAGMENT_TOKENS: boolean;
    
    // Refresh Token (3 toggles)
    REUSABLE_REFRESH_TOKENS: boolean;
    INFINITE_REFRESH_LIFETIME: boolean;
    SKIP_REFRESH_ROTATION: boolean;
    
    // Flow-Specific (3 toggles)
    IMPLICIT_FLOW: boolean;
    PASSWORD_GRANT: boolean;
    LOG_CREDENTIALS: boolean;
    
    // Other (4 toggles)
    NO_RATE_LIMITING: boolean;
    SKIP_CERT_VALIDATION: boolean;
    CLIENT_OPEN_REDIRECT: boolean;
    VERBOSE_ERROR_MESSAGES: boolean;
  };
  
  // Metadata
  acceptedTerms: boolean;
  lastModified: string;
}

// Default: All secure
const SECURE_DEFAULTS: VulnerabilityConfig = {
  enabled: false,
  toggles: {
    DISABLE_PKCE: false,
    SKIP_STATE_VALIDATION: false,
    // ... all toggles false
  },
  acceptedTerms: false,
  lastModified: new Date().toISOString()
};
```

### 1.2 Storage Strategy

**In-Memory Primary Storage** (recommended):

```javascript
// Global vulnerability configuration
let vulnerabilityConfig = { ...SECURE_DEFAULTS };

// Getters/Setters
function getVulnerabilityConfig() {
  return { ...vulnerabilityConfig }; // Return copy
}

function setVulnerabilityConfig(config) {
  vulnerabilityConfig = { ...config };
  notifyConfigListeners(config);
}

function resetToSecureDefaults() {
  vulnerabilityConfig = { ...SECURE_DEFAULTS };
  notifyConfigListeners(vulnerabilityConfig);
}

// Reset on page unload (don't persist vulnerable state)
window.addEventListener('beforeunload', () => {
  if (vulnerabilityConfig.enabled) {
    console.warn('Resetting vulnerability mode on exit');
    resetToSecureDefaults();
  }
});
```

**Session Storage** (optional, for persistence within session):

```javascript
function saveToSession() {
  sessionStorage.setItem('vulnerabilityConfig', JSON.stringify(vulnerabilityConfig));
}

function loadFromSession() {
  const stored = sessionStorage.getItem('vulnerabilityConfig');
  if (stored) {
    vulnerabilityConfig = JSON.parse(stored);
  }
}

// Load on startup (if user wants to continue from previous session)
loadFromSession();
```

**DO NOT use localStorage** - Vulnerable configurations should never persist across browser sessions.

### 1.3 OAuth2Client Integration

**Main OAuth2 Client Class**:

```javascript
class OAuth2Client {
  constructor(config, vulnerabilityConfig = SECURE_DEFAULTS) {
    this.config = config; // Client configuration
    this.vuln = vulnerabilityConfig.toggles; // Shorthand
    this.vulnerabilityMode = vulnerabilityConfig.enabled;
    
    // Warn if vulnerability mode active
    if (this.vulnerabilityMode && this.hasActiveVulnerabilities()) {
      console.warn('üö® VULNERABILITY MODE ACTIVE');
      this.logActiveVulnerabilities();
    }
  }
  
  hasActiveVulnerabilities() {
    return Object.values(this.vuln).some(v => v === true);
  }
  
  logActiveVulnerabilities() {
    Object.entries(this.vuln)
      .filter(([key, value]) => value === true)
      .forEach(([key]) => {
        console.warn(`  - ${key} enabled`);
      });
  }
  
  // Authorization flow methods...
  // Token management methods...
  // Validation methods...
}
```

### 1.4 Authorization Request Builder

```javascript
class OAuth2Client {
  // ...
  
  buildAuthorizationRequest() {
    const params = {
      response_type: this.config.responseType || 'code',
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUri,
      scope: this.config.scope
    };
    
    // PKCE (unless disabled)
    if (!this.vuln.DISABLE_PKCE) {
      const verifier = this.generateCodeVerifier();
      const challenge = this.generateCodeChallenge(verifier);
      params.code_challenge = challenge;
      params.code_challenge_method = 'S256';
      this.storeCodeVerifier(verifier);
    } else {
      console.warn('üö® PKCE disabled - authorization codes vulnerable!');
    }
    
    // State parameter
    if (!this.vuln.SKIP_STATE_VALIDATION) {
      let state;
      if (this.vuln.PREDICTABLE_STATE) {
        state = Date.now().toString(); // Predictable
        console.warn('‚ö†Ô∏è Using predictable state - CSRF protection weakened');
      } else {
        state = this.generateSecureState(); // Cryptographically random
      }
      params.state = state;
      this.storeState(state);
    } else {
      console.warn('üö® State validation disabled - CSRF attacks possible!');
    }
    
    // Issuer parameter (RFC 9207)
    if (!this.vuln.DISABLE_ISS_CHECK) {
      params.iss = this.config.issuer;
    }
    
    // Build URL
    const url = new URL(this.getAuthorizationEndpoint());
    
    // HTTPS enforcement
    if (!this.vuln.HTTP_AUTHORIZATION_ENDPOINT) {
      if (url.protocol !== 'https:' && url.hostname !== 'localhost') {
        throw new Error('Authorization endpoint must use HTTPS');
      }
    } else {
      console.warn('‚ö†Ô∏è HTTP authorization endpoint allowed - network interception possible');
    }
    
    Object.entries(params).forEach(([key, value]) => {
      url.searchParams.set(key, value);
    });
    
    return url.toString();
  }
  
  generateCodeVerifier() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return base64urlEncode(array);
  }
  
  generateCodeChallenge(verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    return crypto.subtle.digest('SHA-256', data)
      .then(hash => base64urlEncode(new Uint8Array(hash)));
  }
  
  generateSecureState() {
    const array = new Uint8Array(32); // 256 bits
    crypto.getRandomValues(array);
    return base64urlEncode(array);
  }
}
```

### 1.5 Authorization Response Handler

```javascript
class OAuth2Client {
  // ...
  
  handleAuthorizationResponse(callbackUrl) {
    const params = new URLSearchParams(new URL(callbackUrl).search);
    
    // Check for errors
    if (params.has('error')) {
      const error = params.get('error');
      const description = params.get('error_description');
      throw new OAuth2Error(error, description);
    }
    
    // State validation
    if (!this.vuln.SKIP_STATE_VALIDATION) {
      const receivedState = params.get('state');
      const expectedState = this.retrieveState();
      
      if (!expectedState) {
        throw new Error('No state found - possible CSRF attack');
      }
      
      if (receivedState !== expectedState) {
        throw new Error('State mismatch - possible CSRF attack');
      }
      
      this.clearState(); // Single use
    } else {
      console.warn('üö® State validation skipped - accepting any state');
    }
    
    // Issuer validation (RFC 9207)
    if (!this.vuln.DISABLE_ISS_CHECK) {
      const receivedIss = params.get('iss');
      if (receivedIss && receivedIss !== this.config.issuer) {
        throw new Error(`Issuer mismatch: expected ${this.config.issuer}, got ${receivedIss}`);
      }
    }
    
    // Redirect URI validation
    const redirectUri = params.get('redirect_uri') || this.config.redirectUri;
    if (!this.vuln.LAX_REDIRECT_URI && !this.vuln.PATTERN_MATCHING_URI) {
      if (!this.validateRedirectUri(redirectUri)) {
        throw new Error('Invalid redirect_uri');
      }
    }
    
    // Extract code
    const code = params.get('code');
    if (!code) {
      throw new Error('No authorization code received');
    }
    
    return code;
  }
  
  validateRedirectUri(uri) {
    if (this.vuln.LAX_REDIRECT_URI) {
      // Wildcard matching (vulnerable)
      console.warn('‚ö†Ô∏è Using lax redirect URI validation');
      return this.config.registeredRedirectUris.some(registered => {
        if (registered.endsWith('/*')) {
          return uri.startsWith(registered.slice(0, -2));
        }
        return uri === registered;
      });
    }
    
    if (this.vuln.PATTERN_MATCHING_URI) {
      // Pattern matching (vulnerable)
      console.warn('‚ö†Ô∏è Using pattern-based redirect URI validation');
      return this.config.registeredRedirectUris.some(registered => {
        const pattern = new RegExp(`^${registered}`);
        return pattern.test(uri);
      });
    }
    
    // Exact matching (secure)
    return this.config.registeredRedirectUris.includes(uri);
  }
}
```

### 1.6 Token Exchange

```javascript
class OAuth2Client {
  // ...
  
  async exchangeCodeForTokens(code) {
    const body = {
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: this.config.redirectUri
    };
    
    // Client authentication
    let headers = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };
    
    if (this.config.clientType === 'confidential') {
      if (!this.vuln.SKIP_CLIENT_AUTH) {
        if (this.vuln.WEAK_CLIENT_SECRET) {
          console.warn('‚ö†Ô∏è Using weak client secret');
        }
        // Basic Auth
        const credentials = btoa(`${this.config.clientId}:${this.config.clientSecret}`);
        headers['Authorization'] = `Basic ${credentials}`;
      } else {
        console.warn('üö® Client authentication skipped!');
        // No auth header - vulnerable
      }
    }
    
    // Public client includes client_id in body
    if (this.config.clientType === 'public') {
      body.client_id = this.config.clientId;
    }
    
    // PKCE code verifier
    if (!this.vuln.DISABLE_PKCE) {
      const verifier = this.retrieveCodeVerifier();
      if (!verifier) {
        throw new Error('PKCE verifier not found');
      }
      body.code_verifier = verifier;
      this.clearCodeVerifier(); // Single use
    }
    
    // Token endpoint URL
    const tokenEndpoint = this.getTokenEndpoint();
    
    // HTTPS enforcement
    if (!this.vuln.HTTP_TOKEN_ENDPOINT) {
      const url = new URL(tokenEndpoint);
      if (url.protocol !== 'https:' && url.hostname !== 'localhost') {
        throw new Error('Token endpoint must use HTTPS');
      }
    }
    
    // Make request
    const response = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: headers,
      body: new URLSearchParams(body)
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new OAuth2Error(error.error, error.error_description);
    }
    
    const tokens = await response.json();
    
    // Store tokens
    this.storeTokens(tokens);
    
    return tokens;
  }
}
```

### 1.7 Token Validation

```javascript
class OAuth2Client {
  // ...
  
  async validateAccessToken(token) {
    // Decode JWT
    const { header, payload, signature } = this.decodeJWT(token);
    
    // Algorithm validation (CRITICAL)
    if (!this.vuln.ACCEPT_NONE_ALGORITHM) {
      if (header.alg === 'none' || header.alg === 'None' || header.alg === 'NONE') {
        throw new Error('alg=none not allowed');
      }
    } else {
      console.error('üö® CRITICAL: Accepting alg=none (unsigned JWTs)');
      if (header.alg === 'none') {
        // Skip all other validation
        return payload;
      }
    }
    
    // Algorithm flexibility check
    if (!this.vuln.FLEXIBLE_JWT_ALGORITHM) {
      const expectedAlg = this.config.expectedAlgorithm || 'RS256';
      if (header.alg !== expectedAlg) {
        throw new Error(`Invalid algorithm: expected ${expectedAlg}, got ${header.alg}`);
      }
    } else {
      console.warn('‚ö†Ô∏è Accepting any JWT algorithm - algorithm confusion possible');
    }
    
    // Signature verification
    if (!this.vuln.SKIP_JWT_VERIFICATION) {
      const jwks = await this.getJWKS();
      const publicKey = this.findKey(jwks, header.kid);
      const valid = await this.verifySignature(token, publicKey, header.alg);
      
      if (!valid) {
        throw new Error('Invalid JWT signature');
      }
    } else {
      console.error('üö® CRITICAL: JWT signature verification skipped!');
    }
    
    // Expiration check
    if (!this.vuln.SKIP_EXPIRATION_CHECK) {
      const now = Math.floor(Date.now() / 1000);
      if (payload.exp && payload.exp < now) {
        throw new Error('Token expired');
      }
    } else {
      console.warn('‚ö†Ô∏è Expiration check skipped - expired tokens accepted');
    }
    
    // Issuer check
    if (!this.vuln.SKIP_ISS_CHECK) {
      if (payload.iss !== this.config.issuer) {
        throw new Error(`Invalid issuer: expected ${this.config.issuer}, got ${payload.iss}`);
      }
    }
    
    // Audience check
    if (!this.vuln.SKIP_AUD_CHECK) {
      const aud = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
      if (!aud.includes(this.config.clientId)) {
        throw new Error('Token audience does not include this client');
      }
    }
    
    return payload;
  }
  
  async validateIDToken(idToken, accessToken) {
    const payload = await this.validateAccessToken(idToken); // Reuse validation
    
    // Nonce check (OIDC)
    if (!this.vuln.SKIP_NONCE) {
      const expectedNonce = this.retrieveNonce();
      if (expectedNonce && payload.nonce !== expectedNonce) {
        throw new Error('Nonce mismatch');
      }
      this.clearNonce();
    }
    
    // at_hash validation (OIDC)
    if (!this.vuln.SKIP_AT_HASH && accessToken) {
      const expectedHash = await this.calculateAtHash(accessToken);
      if (payload.at_hash !== expectedHash) {
        throw new Error('at_hash mismatch - access token substitution possible');
      }
    }
    
    return payload;
  }
  
  decodeJWT(token) {
    const parts = token.split('.');
    if (parts.length !== 3) {
      throw new Error('Invalid JWT format');
    }
    
    const [headerB64, payloadB64, signatureB64] = parts;
    
    const header = JSON.parse(atob(headerB64));
    const payload = JSON.parse(atob(payloadB64));
    
    return { header, payload, signature: signatureB64 };
  }
}
```

### 1.8 Token Storage

```javascript
class OAuth2Client {
  // ...
  
  storeTokens(tokens) {
    if (this.vuln.LOCALSTORAGE_TOKENS) {
      console.error('üö® CRITICAL: Storing tokens in localStorage - XSS vulnerability!');
      localStorage.setItem('access_token', tokens.access_token);
      if (tokens.refresh_token) {
        localStorage.setItem('refresh_token', tokens.refresh_token);
      }
      if (tokens.id_token) {
        localStorage.setItem('id_token', tokens.id_token);
      }
    } else {
      // Secure: In-memory storage
      this.tokens = {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        id_token: tokens.id_token,
        expires_at: Date.now() + (tokens.expires_in * 1000)
      };
    }
    
    if (this.vuln.ALLOW_TOKEN_EXPORT) {
      console.warn('‚ö†Ô∏è Token export allowed - tokens may leak');
      // Make tokens accessible globally (vulnerable)
      window.oauth_tokens = tokens;
    }
  }
  
  retrieveTokens() {
    if (this.vuln.LOCALSTORAGE_TOKENS) {
      return {
        access_token: localStorage.getItem('access_token'),
        refresh_token: localStorage.getItem('refresh_token'),
        id_token: localStorage.getItem('id_token')
      };
    }
    
    return this.tokens;
  }
}
```

### 1.9 API Request Builder

```javascript
class OAuth2Client {
  // ...
  
  async callAPI(url, options = {}) {
    const tokens = this.retrieveTokens();
    
    if (!tokens.access_token) {
      throw new Error('No access token available');
    }
    
    // Build request
    let requestUrl = url;
    const requestOptions = { ...options };
    
    // Token transmission
    if (this.vuln.ALLOW_TOKEN_IN_URL) {
      console.error('üö® CRITICAL: Sending token in URL - multiple leakage vectors!');
      requestUrl = `${url}${url.includes('?') ? '&' : '?'}access_token=${tokens.access_token}`;
    } else {
      // Secure: Authorization header
      requestOptions.headers = {
        ...requestOptions.headers,
        'Authorization': `Bearer ${tokens.access_token}`
      };
    }
    
    // HTTPS enforcement
    const apiUrl = new URL(requestUrl);
    if (!this.vuln.HTTP_RESOURCE_SERVER) {
      if (apiUrl.protocol !== 'https:' && apiUrl.hostname !== 'localhost') {
        throw new Error('Resource server must use HTTPS');
      }
    } else {
      console.warn('‚ö†Ô∏è HTTP resource server allowed - token interception possible');
    }
    
    // Make request
    const response = await fetch(requestUrl, requestOptions);
    
    if (response.status === 401) {
      // Token expired, try refresh
      if (tokens.refresh_token) {
        await this.refreshAccessToken();
        // Retry with new token
        return this.callAPI(url, options);
      }
    }
    
    return response;
  }
}
```

---

## 2. Testing Strategy

### 2.1 Unit Tests for Vulnerability Toggles

**Test Structure**:

```javascript
describe('Vulnerability Toggles', () => {
  
  describe('DISABLE_PKCE', () => {
    it('should omit PKCE parameters when enabled', () => {
      const client = new OAuth2Client(config, {
        enabled: true,
        toggles: { DISABLE_PKCE: true }
      });
      
      const authUrl = client.buildAuthorizationRequest();
      const params = new URL(authUrl).searchParams;
      
      expect(params.has('code_challenge')).toBe(false);
      expect(params.has('code_challenge_method')).toBe(false);
    });
    
    it('should include PKCE parameters when disabled', () => {
      const client = new OAuth2Client(config, {
        enabled: false,
        toggles: { DISABLE_PKCE: false }
      });
      
      const authUrl = client.buildAuthorizationRequest();
      const params = new URL(authUrl).searchParams;
      
      expect(params.has('code_challenge')).toBe(true);
      expect(params.get('code_challenge_method')).toBe('S256');
    });
    
    it('should allow code exchange without verifier when enabled', async () => {
      const client = new OAuth2Client(config, {
        enabled: true,
        toggles: { DISABLE_PKCE: true }
      });
      
      // Mock token endpoint
      fetchMock.mockResponseOnce(JSON.stringify({
        access_token: 'test_token'
      }));
      
      const tokens = await client.exchangeCodeForTokens('test_code');
      
      const requestBody = fetchMock.mock.calls[0][1].body;
      expect(requestBody).not.toContain('code_verifier');
    });
  });
  
  describe('SKIP_STATE_VALIDATION', () => {
    it('should accept mismatched state when enabled', () => {
      const client = new OAuth2Client(config, {
        enabled: true,
        toggles: { SKIP_STATE_VALIDATION: true }
      });
      
      // Store expected state
      client.storeState('expected_state');
      
      // Receive different state
      const callbackUrl = 'http://localhost/callback?code=123&state=different_state';
      
      // Should NOT throw
      expect(() => {
        client.handleAuthorizationResponse(callbackUrl);
      }).not.toThrow();
    });
    
    it('should reject mismatched state when disabled', () => {
      const client = new OAuth2Client(config, {
        enabled: false,
        toggles: { SKIP_STATE_VALIDATION: false }
      });
      
      client.storeState('expected_state');
      
      const callbackUrl = 'http://localhost/callback?code=123&state=different_state';
      
      // Should throw
      expect(() => {
        client.handleAuthorizationResponse(callbackUrl);
      }).toThrow('State mismatch');
    });
  });
  
  describe('ACCEPT_NONE_ALGORITHM', () => {
    it('should accept unsigned JWT when enabled', async () => {
      const client = new OAuth2Client(config, {
        enabled: true,
        toggles: { ACCEPT_NONE_ALGORITHM: true }
      });
      
      // Create unsigned JWT (alg=none)
      const header = { alg: 'none', typ: 'JWT' };
      const payload = { sub: 'attacker', exp: Date.now() / 1000 + 3600 };
      const unsignedJWT = `${btoa(JSON.stringify(header))}.${btoa(JSON.stringify(payload))}.`;
      
      // Should NOT throw
      const validated = await client.validateAccessToken(unsignedJWT);
      expect(validated.sub).toBe('attacker');
    });
    
    it('should reject unsigned JWT when disabled', async () => {
      const client = new OAuth2Client(config, {
        enabled: false,
        toggles: { ACCEPT_NONE_ALGORITHM: false }
      });
      
      const header = { alg: 'none', typ: 'JWT' };
      const payload = { sub: 'attacker', exp: Date.now() / 1000 + 3600 };
      const unsignedJWT = `${btoa(JSON.stringify(header))}.${btoa(JSON.stringify(payload))}.`;
      
      // Should throw
      await expect(client.validateAccessToken(unsignedJWT))
        .rejects.toThrow('alg=none not allowed');
    });
  });
  
  // ... tests for all other toggles
});
```

### 2.2 Integration Tests

**Attack Scenario Tests**:

```javascript
describe('Attack Scenarios', () => {
  
  describe('Authorization Code Interception (No PKCE)', () => {
    it('should demonstrate successful code interception attack', async () => {
      // Setup vulnerable client
      const vulnerableClient = new OAuth2Client(config, {
        enabled: true,
        toggles: {
          DISABLE_PKCE: true,
          HTTP_AUTHORIZATION_ENDPOINT: true
        }
      });
      
      // Victim initiates authorization
      const authUrl = vulnerableClient.buildAuthorizationRequest();
      
      // Simulate authorization (would normally be user interaction)
      const code = 'intercepted_code_123';
      
      // ATTACKER intercepts code
      const attackerClient = new OAuth2Client(config, {
        enabled: true,
        toggles: { DISABLE_PKCE: true }
      });
      
      // Mock token endpoint
      fetchMock.mockResponseOnce(JSON.stringify({
        access_token: 'stolen_token',
        token_type: 'Bearer'
      }));
      
      // Attacker successfully exchanges code
      const tokens = await attackerClient.exchangeCodeForTokens(code);
      
      expect(tokens.access_token).toBe('stolen_token');
    });
    
    it('should prevent code interception with PKCE', async () => {
      // Setup secure client
      const secureClient = new OAuth2Client(config, {
        enabled: false,
        toggles: { DISABLE_PKCE: false }
      });
      
      // Victim initiates authorization
      const authUrl = secureClient.buildAuthorizationRequest();
      const code = 'pkce_protected_code_456';
      
      // ATTACKER intercepts code but NOT verifier
      const attackerClient = new OAuth2Client(config, {
        enabled: false,
        toggles: { DISABLE_PKCE: false }
      });
      
      // Mock token endpoint - returns error
      fetchMock.mockResponseOnce(
        JSON.stringify({
          error: 'invalid_grant',
          error_description: 'PKCE verification failed'
        }),
        { status: 400 }
      );
      
      // Attacker CANNOT exchange code without verifier
      await expect(attackerClient.exchangeCodeForTokens(code))
        .rejects.toThrow();
    });
  });
  
  describe('CSRF Attack (No State Validation)', () => {
    it('should demonstrate successful CSRF attack', async () => {
      const vulnerableClient = new OAuth2Client(config, {
        enabled: true,
        toggles: { SKIP_STATE_VALIDATION: true }
      });
      
      // Attacker crafts malicious callback URL
      const maliciousUrl = 'http://localhost/callback?code=attacker_code&state=attacker_state';
      
      // Victim's client accepts (no state validation)
      const code = vulnerableClient.handleAuthorizationResponse(maliciousUrl);
      
      expect(code).toBe('attacker_code');
      // Attack succeeded - victim's session linked to attacker's authorization
    });
  });
  
  // ... more attack scenarios
});
```

### 2.3 UI/UX Tests

```javascript
describe('Vulnerability Mode UI', () => {
  
  it('should display warning banner when vulnerabilities active', () => {
    render(<OAuth2Tool vulnerabilityConfig={{
      enabled: true,
      toggles: { DISABLE_PKCE: true }
    }} />);
    
    expect(screen.getByText(/VULNERABILITY MODE ACTIVE/i)).toBeInTheDocument();
    expect(screen.getByText(/PKCE DISABLED/i)).toBeInTheDocument();
  });
  
  it('should show green indicator when secure', () => {
    render(<OAuth2Tool vulnerabilityConfig={SECURE_DEFAULTS} />);
    
    expect(screen.getByText(/Secure Mode/i)).toBeInTheDocument();
    expect(screen.getByRole('status')).toHaveClass('secure');
  });
  
  it('should require terms acceptance before enabling', () => {
    render(<VulnerabilityModePanel />);
    
    const enableButton = screen.getByRole('button', { name: /Enable Vulnerability Mode/i });
    fireEvent.click(enableButton);
    
    expect(screen.getByText(/Terms of Use/i)).toBeInTheDocument();
  });
});
```

---

## 3. Educational Content System

### 3.1 Content Structure

**Vulnerability Educational Content**:

```javascript
const educationalContent = {
  DISABLE_PKCE: {
    title: 'Authorization Code Interception',
    shortDescription: 'PKCE disabled - authorization codes vulnerable to interception',
    
    fullDescription: `
      Proof Key for Code Exchange (PKCE) binds authorization codes to the 
      original client that requested them. Without PKCE, intercepted codes 
      can be exchanged by attackers.
    `,
    
    attackWalkthrough: [
      {
        step: 1,
        title: 'Victim Initiates Authorization',
        description: 'User clicks "Login with OAuth2" on application',
        visual: 'authorization-request.png'
      },
      {
        step: 2,
        title: 'Authorization Code Issued',
        description: 'After authentication, code sent to redirect_uri',
        visual: 'authorization-response.png'
      },
      {
        step: 3,
        title: 'Attacker Intercepts Code',
        description: 'Code captured via network sniffing, malware, or URI hijacking',
        visual: 'code-interception.png',
        attackHighlight: true
      },
      {
        step: 4,
        title: 'Attacker Exchanges Code',
        description: 'Without PKCE, attacker can exchange code for tokens',
        visual: 'attacker-token-exchange.png',
        attackHighlight: true
      },
      {
        step: 5,
        title: 'Attack Succeeds',
        description: 'Attacker obtains victim\'s access and refresh tokens',
        visual: 'account-compromise.png',
        severity: 'critical'
      }
    ],
    
    realWorldExamples: [
      {
        title: 'OAuth SDK Vulnerability (2019)',
        cve: 'CVE-2019-16156',
        description: 'Popular OAuth library did not enforce PKCE, leading to widespread vulnerability',
        impact: 'Millions of applications vulnerable to code interception'
      }
    ],
    
    mitigation: {
      summary: 'Always use PKCE with S256 method',
      steps: [
        'Generate cryptographically random code_verifier (43-128 characters)',
        'Calculate code_challenge = BASE64URL(SHA256(code_verifier))',
        'Include code_challenge and code_challenge_method=S256 in authorization request',
        'Store code_verifier securely until token exchange',
        'Include code_verifier in token request'
      ],
      codeExample: `
const verifier = generateCodeVerifier(); // 43-128 chars
const challenge = await generateCodeChallenge(verifier);

// Authorization request
const authUrl = buildAuthUrl({
  code_challenge: challenge,
  code_challenge_method: 'S256'
});

// Token request
const tokens = await exchangeCode(code, {
  code_verifier: verifier
});
      `
    },
    
    specReferences: [
      {
        title: 'RFC 7636 - Proof Key for Code Exchange',
        url: 'https://datatracker.ietf.org/doc/html/rfc7636'
      },
      {
        title: 'OAuth 2.0 Security BCP Section 4.8',
        url: 'https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#section-4.8'
      },
      {
        title: 'OAuth 2.1 (PKCE Required)',
        url: 'https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11'
      }
    ],
    
    relatedDocs: [
      'pkce-implementation.md',
      'authorization-code-flow-with-pkce.md',
      'oauth2-oidc-threat-model.md Section 3.2'
    ],
    
    quiz: [
      {
        question: 'Why does PKCE prevent code interception attacks?',
        options: [
          'It encrypts the authorization code',
          'It binds the code to the original requestor cryptographically',
          'It uses HTTPS',
          'It validates the client secret'
        ],
        correct: 1,
        explanation: 'PKCE binds the authorization code to the client through the code_challenge. Only the client with the matching code_verifier can exchange the code.'
      }
    ]
  },
  
  // ... content for all other vulnerabilities
};
```

### 3.2 Interactive Demonstrations

**Attack Simulator Component**:

```jsx
function AttackSimulator({ vulnerability, onComplete }) {
  const [step, setStep] = useState(0);
  const content = educationalContent[vulnerability];
  
  return (
    <div className="attack-simulator">
      <h2>{content.title}</h2>
      
      <ProgressBar current={step} total={content.attackWalkthrough.length} />
      
      <AttackStep
        step={content.attackWalkthrough[step]}
        isAttackHighlight={content.attackWalkthrough[step].attackHighlight}
      />
      
      <div className="controls">
        {step > 0 && (
          <button onClick={() => setStep(step - 1)}>Previous</button>
        )}
        
        {step < content.attackWalkthrough.length - 1 ? (
          <button onClick={() => setStep(step + 1)}>Next Step</button>
        ) : (
          <button onClick={onComplete}>View Mitigation</button>
        )}
      </div>
      
      {content.attackWalkthrough[step].attackHighlight && (
        <AttackWarning>
          ‚ö†Ô∏è This is where the attack occurs. In a secure implementation,
          this step would fail.
        </AttackWarning>
      )}
    </div>
  );
}
```

### 3.3 Difficulty Levels and Learning Paths

**Learning Path System**:

```javascript
const learningPaths = {
  beginner: {
    title: 'OAuth2 Security Fundamentals',
    description: 'Start here to understand core OAuth2 security concepts',
    estimatedTime: '2 hours',
    vulnerabilities: [
      {
        toggle: 'DISABLE_PKCE',
        reason: 'Foundational concept - code binding',
        prerequisites: []
      },
      {
        toggle: 'SKIP_STATE_VALIDATION',
        reason: 'Classic web security - CSRF protection',
        prerequisites: ['DISABLE_PKCE']
      },
      {
        toggle: 'LOCALSTORAGE_TOKENS',
        reason: 'Common mistake - storage security',
        prerequisites: []
      },
      {
        toggle: 'ALLOW_TOKEN_IN_URL',
        reason: 'Clear vulnerability - transport security',
        prerequisites: ['LOCALSTORAGE_TOKENS']
      }
    ]
  },
  
  intermediate: {
    title: 'Protocol-Level Vulnerabilities',
    description: 'Deeper understanding of OAuth2/OIDC protocols',
    estimatedTime: '4 hours',
    prerequisites: ['beginner'],
    vulnerabilities: [
      { toggle: 'LAX_REDIRECT_URI', prerequisites: ['SKIP_STATE_VALIDATION'] },
      { toggle: 'SKIP_AT_HASH', prerequisites: ['DISABLE_PKCE'] },
      { toggle: 'REUSABLE_REFRESH_TOKENS', prerequisites: [] },
      { toggle: 'SKIP_EXPIRATION_CHECK', prerequisites: [] },
      { toggle: 'PATTERN_MATCHING_URI', prerequisites: ['LAX_REDIRECT_URI'] }
    ]
  },
  
  advanced: {
    title: 'Advanced Attacks and Edge Cases',
    description: 'Complex attack chains and cryptographic vulnerabilities',
    estimatedTime: '6 hours',
    prerequisites: ['beginner', 'intermediate'],
    vulnerabilities: [
      { toggle: 'ACCEPT_NONE_ALGORITHM', prerequisites: ['SKIP_JWT_VERIFICATION'] },
      { toggle: 'FLEXIBLE_JWT_ALGORITHM', prerequisites: ['ACCEPT_NONE_ALGORITHM'] },
      { toggle: 'DISABLE_ISS_CHECK', prerequisites: [] },
      { toggle: 'PKCE_DOWNGRADE', prerequisites: ['DISABLE_PKCE'] },
      { toggle: 'ALLOW_SCOPE_ESCALATION', prerequisites: [] }
    ]
  },
  
  expert: {
    title: 'Attack Chain Combinations',
    description: 'Understanding how vulnerabilities compound',
    estimatedTime: '4 hours',
    prerequisites: ['beginner', 'intermediate', 'advanced'],
    combinations: [
      {
        name: 'Complete Account Takeover',
        toggles: ['HTTP_AUTHORIZATION_ENDPOINT', 'DISABLE_PKCE', 'SKIP_CLIENT_AUTH'],
        description: 'Network interception + code use + no client verification'
      },
      {
        name: 'Phishing Attack Chain',
        toggles: ['SKIP_STATE_VALIDATION', 'LAX_REDIRECT_URI'],
        description: 'CSRF + open redirect = authorization code phishing'
      },
      {
        name: 'Token Forgery',
        toggles: ['ACCEPT_NONE_ALGORITHM', 'SKIP_AUD_CHECK', 'SKIP_EXPIRATION_CHECK'],
        description: 'Unsigned JWT + any audience + never expires'
      }
    ]
  }
};
```

---

## 4. Compliance and Ethical Use

### 4.1 Terms of Use

**Required Acceptance Flow**:

```jsx
function VulnerabilityModeTermsDialog({ onAccept, onDecline }) {
  const [accepted, setAccepted] = useState(false);
  
  return (
    <Dialog title="Vulnerability Mode - Terms of Use">
      <TermsContent>
        <h3>Educational Purpose Only</h3>
        <p>By enabling Vulnerability Mode, you agree to:</p>
        
        <ol>
          <li>Use this feature for EDUCATIONAL PURPOSES ONLY</li>
          <li>NOT use these techniques against systems you do not own</li>
          <li>Obtain explicit written permission before testing any system</li>
          <li>Understand that unauthorized testing may violate:
            <ul>
              <li>Computer Fraud and Abuse Act (U.S.)</li>
              <li>Computer Misuse Act (U.K.)</li>
              <li>Similar laws in your jurisdiction</li>
            </ul>
          </li>
          <li>Take full responsibility for your use of this software</li>
          <li>NOT hold the authors liable for any misuse</li>
        </ol>
        
        <h3>Acceptable Use:</h3>
        <ul>
          <li>‚úì Learning OAuth2/OIDC security</li>
          <li>‚úì Testing your own applications</li>
          <li>‚úì Authorized security assessments</li>
          <li>‚úì Educational demonstrations</li>
        </ul>
        
        <h3>Prohibited Use:</h3>
        <ul>
          <li>‚úó Testing production systems without authorization</li>
          <li>‚úó Attacking third-party applications</li>
          <li>‚úó Circumventing security controls</li>
          <li>‚úó Any illegal activity</li>
        </ul>
      </TermsContent>
      
      <CheckboxLabel>
        <input
          type="checkbox"
          checked={accepted}
          onChange={(e) => setAccepted(e.target.checked)}
        />
        I have read and agree to these terms
      </CheckboxLabel>
      
      <DialogActions>
        <button onClick={onDecline}>Cancel</button>
        <button 
          onClick={onAccept}
          disabled={!accepted}
          className="primary"
        >
          Accept and Continue
        </button>
      </DialogActions>
    </Dialog>
  );
}
```

### 4.2 Data Privacy

**No Real User Data**:

```javascript
// Validation: Ensure only test data used
function validateDemoData(userData) {
  const DEMO_USERS = ['alice', 'bob', 'admin', 'carol'];
  
  if (!DEMO_USERS.includes(userData.username)) {
    throw new Error('Only demonstration accounts allowed in vulnerability mode');
  }
  
  // Ensure no real email addresses
  if (!userData.email.endsWith('@example.com')) {
    throw new Error('Only example.com emails allowed in demonstrations');
  }
}
```

---

## 5. Complete Vulnerability Quick Reference

### 5.1 Master Toggle Table

| Toggle | Category | Attack | Severity | Spec | Related Docs |
|--------|----------|--------|----------|------|--------------|
| **DISABLE_PKCE** | Authorization | Code Interception | üî¥ Critical | RFC 7636, BCP ¬ß4.8 | pkce-implementation.md |
| **SKIP_STATE_VALIDATION** | Authorization | CSRF | üî¥ Critical | RFC 6749 ¬ß10.12, BCP ¬ß4.7 | state-parameter-and-csrf.md |
| **PREDICTABLE_STATE** | Authorization | CSRF (weak) | üü† High | BCP ¬ß4.7.1 | state-parameter-and-csrf.md |
| **LAX_REDIRECT_URI** | Authorization | Open Redirect | üî¥ Critical | RFC 6749 ¬ß3.1.2, BCP ¬ß4.1 | redirect-uri-validation.md |
| **PATTERN_MATCHING_URI** | Authorization | URI Bypass | üü† High | BCP ¬ß4.1.2 | redirect-uri-validation.md |
| **ALLOW_IFRAME** | Authorization | Clickjacking | üü° Medium | RFC 6749 ¬ß10.13 | security-best-current-practice.md |
| **HTTP_AUTHORIZATION_ENDPOINT** | Authorization | Network Interception | üî¥ Critical | BCP ¬ß4.2 | security-best-current-practice.md |
| **DISABLE_ISS_CHECK** | Authorization | Mix-Up Attack | üî¥ Critical | RFC 9207, BCP ¬ß4.4 | oauth2-oidc-threat-model.md |
| **PKCE_DOWNGRADE** | Authorization | PKCE Downgrade | üü† High | BCP ¬ß4.8.2 | pkce-implementation.md |
| **SKIP_CLIENT_AUTH** | Token | Client Impersonation | üî¥ Critical | RFC 6749 ¬ß3.2.1 | client-credentials-flow.md |
| **WEAK_CLIENT_SECRET** | Token | Secret Compromise | üü† High | BCP ¬ß4.14 | security-best-current-practice.md |
| **REUSABLE_AUTH_CODE** | Token | Code Replay | üî¥ Critical | RFC 6749 ¬ß4.1.2 | authorization-code-flow-with-pkce.md |
| **ALLOW_SCOPE_ESCALATION** | Token | Privilege Escalation | üü† High | RFC 6749 ¬ß5.1 | security-best-current-practice.md |
| **HTTP_TOKEN_ENDPOINT** | Token | Network Interception | üî¥ Critical | BCP ¬ß4.2 | security-best-current-practice.md |
| **SKIP_JWT_VERIFICATION** | Validation | Signature Bypass | üî¥ Critical | RFC 7515 | jwt-structure-and-validation.md |
| **ACCEPT_NONE_ALGORITHM** | Validation | alg=none Bypass | üî¥ Critical | RFC 7515 ¬ß8.1 | jwt-structure-and-validation.md |
| **FLEXIBLE_JWT_ALGORITHM** | Validation | Algorithm Confusion | üî¥ Critical | RFC 7515 ¬ß8.2 | jwt-structure-and-validation.md |
| **SKIP_EXPIRATION_CHECK** | Validation | Expired Token Use | üü† High | RFC 7519 ¬ß4.1.4 | jwt-structure-and-validation.md |
| **SKIP_AUD_CHECK** | Validation | Token Misuse | üü† High | RFC 7519 ¬ß4.1.3 | jwt-structure-and-validation.md |
| **SKIP_ISS_CHECK** | Validation | Token Substitution | üî¥ Critical | RFC 7519 ¬ß4.1.1 | jwt-structure-and-validation.md |
| **SKIP_NONCE** | Validation | ID Token Replay | üü† High | OIDC Core ¬ß3.1.3.7 | id-tokens-oidc.md |
| **SKIP_AT_HASH** | Validation | Access Token Injection | üü† High | OIDC Core ¬ß3.1.3.7 | id-tokens-oidc.md |
| **SKIP_HASH_VALIDATION** | Validation | Token Substitution | üü† High | OIDC Core ¬ß3.1.3.7 | id-tokens-oidc.md |
| **LOCALSTORAGE_TOKENS** | Storage | XSS Token Theft | üî¥ Critical | BCP ¬ß4.3.3 | security-best-current-practice.md |
| **INSECURE_REFRESH_STORAGE** | Storage | Refresh Token Theft | üü† High | BCP ¬ß4.13 | refresh-tokens.md |
| **ALLOW_TOKEN_EXPORT** | Storage | Token Leakage | üü° Medium | BCP | security-best-current-practice.md |
| **ALLOW_TOKEN_IN_URL** | Transmission | URL Token Leakage | üî¥ Critical | BCP ¬ß4.2.4 | security-best-current-practice.md |
| **HTTP_RESOURCE_SERVER** | Transmission | Network Interception | üî¥ Critical | BCP ¬ß4.2 | security-best-current-practice.md |
| **ALLOW_FRAGMENT_TOKENS** | Transmission | History Leakage | üü† High | BCP ¬ß2.1.2 | deprecated-implicit-flow.md |
| **REUSABLE_REFRESH_TOKENS** | Refresh | Token Replay | üü† High | BCP ¬ß4.13.2 | refresh-tokens.md |
| **INFINITE_REFRESH_LIFETIME** | Refresh | Indefinite Access | üü° Medium | BCP ¬ß4.13.1 | refresh-tokens.md |
| **SKIP_REFRESH_ROTATION** | Refresh | No Rotation | üü† High | BCP ¬ß4.13.2 | refresh-tokens.md |
| **IMPLICIT_FLOW** | Flow | Multiple Vulnerabilities | üî¥ Critical | BCP ¬ß2.1.2 | deprecated-implicit-flow.md |
| **PASSWORD_GRANT** | Flow | Credential Exposure | üî¥ Critical | BCP ¬ß2.4 | deprecated-resource-owner-password-flow.md |
| **LOG_CREDENTIALS** | Flow | Credential Logging | üî¥ Critical | BCP | Security practices |
| **NO_RATE_LIMITING** | Other | Brute Force | üü° Medium | BCP | security-best-current-practice.md |
| **SKIP_CERT_VALIDATION** | Other | MITM | üî¥ Critical | BCP | security-best-current-practice.md |
| **CLIENT_OPEN_REDIRECT** | Other | Phishing | üü† High | BCP ¬ß4.1.3 | redirect-uri-validation.md |
| **VERBOSE_ERROR_MESSAGES** | Other | Information Disclosure | üü° Medium | BCP | security-best-current-practice.md |

**Total**: 39 vulnerability toggles across 8 categories

---

## Document Metadata

| Property | Value |
|----------|-------|
| **Version** | 1.0.0 |
| **Part** | 4 of 4 (Implementation Guide) |
| **Related Docs** | Parts 1-3, all specification documents |
| **Target** | Claude Code (implementation) |
| **Completeness** | Final comprehensive implementation reference |

---

**Series Complete**: This completes the 4-part vulnerability mode reference documentation covering overview, authorization vulnerabilities, token vulnerabilities, and implementation.
