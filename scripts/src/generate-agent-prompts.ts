#!/usr/bin/env tsx
/**
 * Generate agent prompt files from templates using config.yaml
 *
 * This script reads docs/prompts/config.yaml and generates prompt files
 * from Handlebars templates in docs/prompts/templates/
 *
 * Usage:
 *   tsx scripts/src/generate-agent-prompts.ts
 *   pnpm generate-prompts
 */

import { resolve, join, dirname, relative } from 'path';
import { fileURLToPath } from 'url';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import Handlebars from 'handlebars';
import { loadYaml } from './lib/config-loader.js';
import { buildTemplateContext } from './lib/context-builder.js';
import { success, error, warning, info, colorize } from './lib/colors.js';
import type { Config, PromptConfig, TemplateContext } from './types/config.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Paths
// __dirname is scripts/src, so go up 2 levels to project root
const PROJECT_ROOT = resolve(__dirname, '../..');
const CONFIG_FILE = join(PROJECT_ROOT, 'docs', 'prompts', 'config.yaml');
const TEMPLATE_DIR = join(PROJECT_ROOT, 'docs', 'prompts', 'templates');
const OUTPUT_DIR = join(PROJECT_ROOT, 'docs', 'prompts');

/**
 * Register custom Handlebars helpers
 */
function registerHelpers() {
  // Helper for checking if a value is true
  Handlebars.registerHelper('isTrue', function (value: any) {
    return value === true;
  });

  // Helper for checking if a value is false
  Handlebars.registerHelper('isFalse', function (value: any) {
    return value === false;
  });

  // Helper for greater than comparison
  Handlebars.registerHelper('gt', function (a: number, b: number) {
    return a > b;
  });

  // Helper for equality
  Handlebars.registerHelper('eq', function (a: any, b: any) {
    return a === b;
  });
}

/**
 * Print script header
 */
function printHeader() {
  console.log(colorize('='.repeat(50), 'green'));
  console.log(success('Agent Prompt Generator'));
  console.log(colorize('='.repeat(50), 'green'));
  console.log();
}

/**
 * Generate file header for generated files
 */
function generateFileHeader(templateName: string, context: TemplateContext): string {
  return `<!--
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸  GENERATED FILE - DO NOT EDIT DIRECTLY
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

This file is automatically generated from:
  Template: docs/prompts/templates/${templateName}
  Config:   docs/prompts/config.yaml

To modify this prompt:
  1. Edit docs/prompts/config.yaml
  2. Run: pnpm generate-prompts

Generated: ${context.generation_timestamp}
Component: ${context.component_name}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
-->

`;
}

/**
 * Generate a single prompt file from template
 */
function generatePrompt(
  templateFile: string,
  outputFile: string,
  description: string,
  modelVar: string,
  context: TemplateContext
): boolean {
  const templatePath = join(TEMPLATE_DIR, templateFile);

  if (!existsSync(templatePath)) {
    console.log(error(`âœ— Template not found: ${templatePath}`));
    return false;
  }

  process.stdout.write(`  Generating ${description}... `);

  try {
    // Load and compile template
    const templateSource = readFileSync(templatePath, 'utf-8');
    const template = Handlebars.compile(templateSource);

    // Add model-specific variable
    const templateContext = {
      ...context,
      model: (context as any)[modelVar],
    };

    // Render template
    const renderedContent = template(templateContext);

    // Generate file with header
    const header = generateFileHeader(templateFile, context);
    const fullContent = header + renderedContent;

    // Write output file
    const outputPath = join(OUTPUT_DIR, outputFile);
    writeFileSync(outputPath, fullContent, 'utf-8');

    console.log(success('âœ“'));
    return true;
  } catch (err) {
    console.log(error('âœ—'));
    console.log(error(`ERROR: ${err instanceof Error ? err.message : String(err)}`));
    return false;
  }
}

/**
 * Main entry point
 */
async function main() {
  printHeader();

  // Check template directory exists
  if (!existsSync(TEMPLATE_DIR)) {
    console.error(error(`ERROR: Template directory not found: ${TEMPLATE_DIR}`));
    process.exit(1);
  }

  // Load configuration
  console.log(info(`ðŸ“‹ Reading configuration from: ${CONFIG_FILE}`));
  console.log();

  const configResult = loadYaml(CONFIG_FILE);
  if (!configResult.success) {
    console.error(error(`ERROR: ${configResult.error!.message}`));
    if (configResult.error!.details) {
      console.error(error(`Details: ${configResult.error!.details}`));
    }
    process.exit(1);
  }

  const config = configResult.config! as Config;

  // Display current configuration
  console.log(warning(`Component: ${config.component.name}`));
  console.log(warning(`Type: ${config.component.type}`));
  console.log(warning(`GitHub PR: ${config.github.pr}`));
  console.log(warning(`Branch: ${config.github.branch}`));

  // Display session info if multi-session mode
  if (config.session?.enabled) {
    const current = config.session.current;
    const total = config.session.total;
    const sessionKey = `session_${current}` as `session_${number}`;
    const sessionScope = (config.session[sessionKey] as any)?.scope || '';
    console.log(warning(`Session Mode: Enabled (Session ${current} of ${total})`));
    console.log(warning(`Session Scope: ${sessionScope}`));
  }

  console.log();

  // Build template context
  const context = buildTemplateContext(config);

  // Register custom Handlebars helpers
  registerHelpers();

  // Generate all prompts
  console.log(info('ðŸ”¨ Generating prompt files:'));
  console.log();

  const prompts: PromptConfig[] = [
    {
      templateFile: 'agent-technical-architect.md.template',
      outputFile: 'agent-technical-architect.md',
      description: 'technical-architect prompt',
      modelVar: 'technical_architect',
    },
    {
      templateFile: 'agent-feature-implementer-plan-mode.md.template',
      outputFile: 'agent-feature-implementer-plan-mode.md',
      description: 'feature-implementer-plan-mode prompt',
      modelVar: 'feature_implementer_plan',
    },
    {
      templateFile: 'agent-feature-implementer.md.template',
      outputFile: 'agent-feature-implementer.md',
      description: 'feature-implementer prompt',
      modelVar: 'feature_implementer',
    },
    {
      templateFile: 'agent-test-suite-generator.md.template',
      outputFile: 'agent-test-suite-generator.md',
      description: 'test-suite-generator prompt',
      modelVar: 'test_suite_generator',
    },
    {
      templateFile: 'agent-code-security-reviewer.md.template',
      outputFile: 'agent-code-security-reviewer.md',
      description: 'code-security-reviewer prompt',
      modelVar: 'code_security_reviewer',
    },
  ];

  let successCount = 0;
  for (const prompt of prompts) {
    if (
      generatePrompt(
        prompt.templateFile,
        prompt.outputFile,
        prompt.description,
        prompt.modelVar,
        context
      )
    ) {
      successCount++;
    }
  }

  console.log();
  console.log(colorize('='.repeat(50), 'green'));
  console.log(success(`âœ“ Successfully generated ${successCount} agent prompt files`));
  console.log(colorize('='.repeat(50), 'green'));
  console.log();
  console.log('Generated files:');
  for (const prompt of prompts) {
    const relPath = relative(PROJECT_ROOT, join(OUTPUT_DIR, prompt.outputFile));
    console.log(`  - ${relPath}`);
  }
  console.log();
  console.log(warning('Note: These are generated files. Do not edit directly!'));
  console.log(warning('      Edit config.yaml and re-run this script instead.'));
  console.log();

  process.exit(successCount === prompts.length ? 0 : 1);
}

main().catch((err) => {
  console.error(error('\nUnexpected error:'));
  console.error(error(err instanceof Error ? err.message : String(err)));
  if (err instanceof Error && err.stack) {
    console.error(error('\nStack trace:'));
    console.error(err.stack);
  }
  process.exit(2);
});
