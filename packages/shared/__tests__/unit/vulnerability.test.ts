/**
 * Vulnerability Types Test Suite
 *
 * Tests for vulnerability configuration, toggles, and categories.
 * Covers vulnerability mode for educational purposes.
 */

import { describe, it, expect } from 'vitest';
import {
  VulnerabilityConfig,
  VulnerabilityToggles,
  SECURE_DEFAULTS,
  VulnerabilityToggleMetadata,
  VULNERABILITY_METADATA,
  VulnerabilityCategory,
  VulnerabilityCategoryMetadata,
  CATEGORY_METADATA,
} from '../../src/vulnerability';

describe('Vulnerability Types - Day 2', () => {
  describe('VulnerabilityConfig Interface', () => {
    it('should accept valid vulnerability configuration', () => {
      const config: VulnerabilityConfig = {
        enabled: false,
        toggles: SECURE_DEFAULTS,
        lastModified: '2024-01-06T10:00:00Z',
        warningAcknowledged: false,
      };

      expect(config.enabled).toBe(false);
      expect(config.warningAcknowledged).toBe(false);
      expect(config.toggles).toBeDefined();
    });

    it('should allow enabling vulnerability mode', () => {
      const config: VulnerabilityConfig = {
        enabled: true,
        toggles: {
          ...SECURE_DEFAULTS,
          DISABLE_PKCE: true,
        },
        lastModified: '2024-01-06T10:00:00Z',
        warningAcknowledged: true,
      };

      expect(config.enabled).toBe(true);
      expect(config.toggles.DISABLE_PKCE).toBe(true);
      expect(config.warningAcknowledged).toBe(true);
    });

    it('should track last modification timestamp', () => {
      const timestamp = '2024-01-06T15:30:45Z';
      const config: VulnerabilityConfig = {
        enabled: false,
        toggles: SECURE_DEFAULTS,
        lastModified: timestamp,
        warningAcknowledged: false,
      };

      expect(config.lastModified).toBe(timestamp);
    });

    it('should require warning acknowledgment when enabled', () => {
      const config: VulnerabilityConfig = {
        enabled: true,
        toggles: SECURE_DEFAULTS,
        lastModified: '2024-01-06T10:00:00Z',
        warningAcknowledged: true,
      };

      expect(config.warningAcknowledged).toBe(true);
    });
  });

  describe('VulnerabilityToggles Interface', () => {
    it('should include DISABLE_PKCE toggle', () => {
      const toggles: VulnerabilityToggles = {
        DISABLE_PKCE: false,
      };

      expect(toggles.DISABLE_PKCE).toBe(false);
    });

    it('should allow enabling DISABLE_PKCE vulnerability', () => {
      const toggles: VulnerabilityToggles = {
        DISABLE_PKCE: true,
      };

      expect(toggles.DISABLE_PKCE).toBe(true);
    });

    it('should have all toggles defined in SECURE_DEFAULTS', () => {
      const defaults = SECURE_DEFAULTS;

      expect(defaults).toHaveProperty('DISABLE_PKCE');
      expect(defaults.DISABLE_PKCE).toBe(false);
    });

    it('should have DISABLE_PKCE as only MVP toggle', () => {
      // MVP has only DISABLE_PKCE functional
      const mvpToggles = {
        DISABLE_PKCE: false,
      };

      expect(mvpToggles.DISABLE_PKCE).toBe(false);
    });

    it('should support all future phase toggles in structure', () => {
      // All 39 toggles should be part of the interface
      const allToggles: VulnerabilityToggles = {
        // MVP
        DISABLE_PKCE: false,
        // Phase 2+ toggles
        DISABLE_STATE: false,
        PREDICTABLE_STATE: false,
        SKIP_STATE_VERIFICATION: false,
        DISABLE_NONCE: false,
        PREDICTABLE_NONCE: false,
        SKIP_NONCE_VERIFICATION: false,
        LAX_REDIRECT_URI: false,
        ALLOW_OPEN_REDIRECT: false,
        PATTERN_MATCHING_URI: false,
        SKIP_SIGNATURE_VERIFICATION: false,
        SKIP_EXPIRATION_CHECK: false,
        SKIP_ISSUER_VALIDATION: false,
        SKIP_AUDIENCE_VALIDATION: false,
        SKIP_AT_HASH: false,
        SKIP_C_HASH: false,
        DISABLE_DPOP: false,
        ALLOW_TOKEN_REUSE: false,
        DISABLE_MTLS: false,
        SKIP_CLIENT_AUTH: false,
        WEAK_CLIENT_SECRET: false,
        CLIENT_SECRET_IN_QUERY: false,
        SKIP_SCOPE_VALIDATION: false,
        ALLOW_SCOPE_ESCALATION: false,
        DISABLE_REFRESH_ROTATION: false,
        REUSABLE_REFRESH: false,
        SKIP_REFRESH_BINDING: false,
        ALLOW_HTTP: false,
        SKIP_CERT_VALIDATION: false,
        ALLOW_FRAGMENT_TOKENS: false,
        ALLOW_TOKENS_IN_HISTORY: false,
        DISABLE_TOKEN_ENCRYPTION: false,
        ALLOW_CODE_REUSE: false,
        PREDICTABLE_AUTH_CODE: false,
        EXTENDED_CODE_LIFETIME: false,
        ALLOW_IFRAME: false,
        DISABLE_CORS: false,
        ALLOW_MIXED_CONTENT: false,
      };

      expect(allToggles.DISABLE_PKCE).toBe(false);
      expect(allToggles.DISABLE_STATE).toBe(false);
      expect(allToggles.ALLOW_MIXED_CONTENT).toBe(false);
    });
  });

  describe('SECURE_DEFAULTS Constant', () => {
    it('should have all toggles set to false', () => {
      const defaults = SECURE_DEFAULTS;

      // MVP toggle
      expect(defaults.DISABLE_PKCE).toBe(false);

      // Verify it's a complete set
      expect(Object.values(defaults).every((v) => v === false)).toBe(true);
    });

    it('should be immutable reference', () => {
      const defaults = SECURE_DEFAULTS;
      expect(defaults).toBeDefined();

      // Verify all toggles are present and false
      for (const key in defaults) {
        if (Object.prototype.hasOwnProperty.call(defaults, key)) {
          expect(defaults[key as keyof VulnerabilityToggles]).toBe(false);
        }
      }
    });
  });

  describe('VulnerabilityCategory Enum', () => {
    it('should define AUTHORIZATION_ENDPOINT category', () => {
      expect(VulnerabilityCategory.AUTHORIZATION_ENDPOINT).toBe('authorization_endpoint');
    });

    it('should define TOKEN_ENDPOINT category', () => {
      expect(VulnerabilityCategory.TOKEN_ENDPOINT).toBe('token_endpoint');
    });

    it('should define TOKEN_VALIDATION category', () => {
      expect(VulnerabilityCategory.TOKEN_VALIDATION).toBe('token_validation');
    });

    it('should define CLIENT_AUTHENTICATION category', () => {
      expect(VulnerabilityCategory.CLIENT_AUTHENTICATION).toBe('client_authentication');
    });

    it('should define STATE_CSRF category', () => {
      expect(VulnerabilityCategory.STATE_CSRF).toBe('state_csrf');
    });

    it('should define REDIRECT_URI category', () => {
      expect(VulnerabilityCategory.REDIRECT_URI).toBe('redirect_uri');
    });

    it('should define TRANSPORT_SECURITY category', () => {
      expect(VulnerabilityCategory.TRANSPORT_SECURITY).toBe('transport_security');
    });

    it('should define TOKEN_BINDING category', () => {
      expect(VulnerabilityCategory.TOKEN_BINDING).toBe('token_binding');
    });

    it('should define TOKEN_LEAKAGE category', () => {
      expect(VulnerabilityCategory.TOKEN_LEAKAGE).toBe('token_leakage');
    });

    it('should define SCOPE_HANDLING category', () => {
      expect(VulnerabilityCategory.SCOPE_HANDLING).toBe('scope_handling');
    });

    it('should define REFRESH_TOKEN category', () => {
      expect(VulnerabilityCategory.REFRESH_TOKEN).toBe('refresh_token');
    });

    it('should define UI_UX_SECURITY category', () => {
      expect(VulnerabilityCategory.UI_UX_SECURITY).toBe('ui_ux_security');
    });
  });

  describe('VulnerabilityCategoryMetadata', () => {
    it('should define metadata for a category', () => {
      const metadata: VulnerabilityCategoryMetadata = {
        category: VulnerabilityCategory.AUTHORIZATION_ENDPOINT,
        name: 'Authorization Endpoint',
        description: 'Vulnerabilities in the authorization endpoint',
        icon: 'shield-alert',
      };

      expect(metadata.category).toBe(VulnerabilityCategory.AUTHORIZATION_ENDPOINT);
      expect(metadata.name).toBe('Authorization Endpoint');
      expect(metadata.description).toBeDefined();
    });

    it('should allow optional icon', () => {
      const metadata: VulnerabilityCategoryMetadata = {
        category: VulnerabilityCategory.TOKEN_ENDPOINT,
        name: 'Token Endpoint',
        description: 'Vulnerabilities in the token endpoint',
      };

      expect(metadata.icon).toBeUndefined();
    });
  });

  describe('CATEGORY_METADATA Registry', () => {
    it('should provide metadata for all categories', () => {
      expect(CATEGORY_METADATA).toBeDefined();
      expect(typeof CATEGORY_METADATA === 'object').toBe(true);
    });

    it('should include metadata for AUTHORIZATION_ENDPOINT category', () => {
      const authEndpointMeta = CATEGORY_METADATA[VulnerabilityCategory.AUTHORIZATION_ENDPOINT];
      expect(authEndpointMeta).toBeDefined();
      expect(authEndpointMeta.category).toBe(VulnerabilityCategory.AUTHORIZATION_ENDPOINT);
    });

    it('should include metadata for TOKEN_ENDPOINT category', () => {
      const tokenEndpointMeta = CATEGORY_METADATA[VulnerabilityCategory.TOKEN_ENDPOINT];
      expect(tokenEndpointMeta).toBeDefined();
      expect(tokenEndpointMeta.category).toBe(VulnerabilityCategory.TOKEN_ENDPOINT);
    });

    it('should include metadata for STATE_CSRF category', () => {
      const stateCsrfMeta = CATEGORY_METADATA[VulnerabilityCategory.STATE_CSRF];
      expect(stateCsrfMeta).toBeDefined();
      expect(stateCsrfMeta.category).toBe(VulnerabilityCategory.STATE_CSRF);
    });
  });

  describe('VulnerabilityToggleMetadata', () => {
    it('should define metadata for DISABLE_PKCE toggle', () => {
      const metadata: VulnerabilityToggleMetadata = {
        key: 'DISABLE_PKCE' as keyof VulnerabilityToggles,
        name: 'Disable PKCE',
        description: 'Removes Proof Key for Code Exchange protection',
        category: VulnerabilityCategory.AUTHORIZATION_ENDPOINT,
        severity: 'critical',
        rfcReferences: ['RFC 7636', 'OAuth 2.1 Section 4.1'],
        attackVector: 'Authorization code interception attack',
        mitigation: 'Always use PKCE (RFC 7636)',
        phase: 'mvp',
        implemented: true,
        demoScenario: 'Remove code_challenge from authorization request',
      };

      expect(metadata.key).toBe('DISABLE_PKCE');
      expect(metadata.severity).toBe('critical');
      expect(metadata.phase).toBe('mvp');
      expect(metadata.implemented).toBe(true);
    });

    it('should allow optional demoScenario', () => {
      const metadata: VulnerabilityToggleMetadata = {
        key: 'DISABLE_PKCE' as keyof VulnerabilityToggles,
        name: 'Disable PKCE',
        description: 'Test description',
        category: VulnerabilityCategory.AUTHORIZATION_ENDPOINT,
        severity: 'critical',
        rfcReferences: ['RFC 7636'],
        attackVector: 'Test attack',
        mitigation: 'Test mitigation',
        phase: 'mvp',
        implemented: true,
      };

      expect(metadata.demoScenario).toBeUndefined();
    });

    it('should track implementation status', () => {
      const mvpImplemented: VulnerabilityToggleMetadata = {
        key: 'DISABLE_PKCE' as keyof VulnerabilityToggles,
        name: 'Disable PKCE',
        description: 'MVP feature',
        category: VulnerabilityCategory.AUTHORIZATION_ENDPOINT,
        severity: 'critical',
        rfcReferences: ['RFC 7636'],
        attackVector: 'Code interception',
        mitigation: 'Use PKCE',
        phase: 'mvp',
        implemented: true,
      };

      const phase2NotImplemented: VulnerabilityToggleMetadata = {
        key: 'DISABLE_STATE' as keyof VulnerabilityToggles,
        name: 'Disable State',
        description: 'Phase 2 feature',
        category: VulnerabilityCategory.STATE_CSRF,
        severity: 'critical',
        rfcReferences: ['RFC 6749 Section 10.12'],
        attackVector: 'CSRF attack',
        mitigation: 'Use state parameter',
        phase: 'phase-2',
        implemented: false,
      };

      expect(mvpImplemented.implemented).toBe(true);
      expect(phase2NotImplemented.implemented).toBe(false);
    });
  });

  describe('VULNERABILITY_METADATA Registry', () => {
    it('should provide metadata for DISABLE_PKCE toggle', () => {
      const disablePkceMetadata = VULNERABILITY_METADATA['DISABLE_PKCE'];
      expect(disablePkceMetadata).toBeDefined();
      expect(disablePkceMetadata.name).toBe('Disable PKCE');
      expect(disablePkceMetadata.severity).toBe('critical');
      expect(disablePkceMetadata.phase).toBe('mvp');
      expect(disablePkceMetadata.implemented).toBe(true);
    });

    it('should indicate future phases for non-MVP toggles', () => {
      const metadata = VULNERABILITY_METADATA;
      // The registry should indicate that Phase 2+ toggles will be added
      expect(metadata).toBeDefined();
    });

    it('should provide RFC references for DISABLE_PKCE', () => {
      const disablePkceMetadata = VULNERABILITY_METADATA['DISABLE_PKCE'];
      expect(disablePkceMetadata.rfcReferences).toBeDefined();
      expect(disablePkceMetadata.rfcReferences.length).toBeGreaterThan(0);
      // Verify at least one reference contains PKCE info
      expect(disablePkceMetadata.rfcReferences.some((ref) => ref.includes('7636') || ref.includes('PKCE'))).toBe(true);
    });

    it('should describe attack vectors for vulnerabilities', () => {
      const disablePkceMetadata = VULNERABILITY_METADATA['DISABLE_PKCE'];
      expect(disablePkceMetadata.attackVector).toBeDefined();
      expect(disablePkceMetadata.attackVector.length).toBeGreaterThan(0);
    });

    it('should provide mitigation guidance', () => {
      const disablePkceMetadata = VULNERABILITY_METADATA['DISABLE_PKCE'];
      expect(disablePkceMetadata.mitigation).toBeDefined();
      expect(disablePkceMetadata.mitigation.length).toBeGreaterThan(0);
    });
  });

  describe('Vulnerability Mode Safety', () => {
    it('should start with secure defaults', () => {
      const config: VulnerabilityConfig = {
        enabled: false,
        toggles: SECURE_DEFAULTS,
        lastModified: '2024-01-06T10:00:00Z',
        warningAcknowledged: false,
      };

      expect(config.enabled).toBe(false);
      expect(config.toggles.DISABLE_PKCE).toBe(false);
    });

    it('should require explicit warning acknowledgment', () => {
      const unsafeConfig: VulnerabilityConfig = {
        enabled: true,
        toggles: { ...SECURE_DEFAULTS, DISABLE_PKCE: true },
        lastModified: '2024-01-06T10:00:00Z',
        warningAcknowledged: false, // Not acknowledged
      };

      // UI should check this
      expect(unsafeConfig.warningAcknowledged).toBe(false);

      const safeConfig: VulnerabilityConfig = {
        enabled: true,
        toggles: { ...SECURE_DEFAULTS, DISABLE_PKCE: true },
        lastModified: '2024-01-06T10:00:00Z',
        warningAcknowledged: true, // Acknowledged
      };

      // Only now should vulnerabilities be allowed
      expect(safeConfig.warningAcknowledged).toBe(true);
    });

    it('should provide educational context for each vulnerability', () => {
      const pkceMetadata = VULNERABILITY_METADATA['DISABLE_PKCE'];
      // Check for comprehensive educational description
      expect(pkceMetadata.description).toBeDefined();
      expect(pkceMetadata.description.length).toBeGreaterThan(0);
      // Verify it includes explanation of what the vulnerability does
      expect(pkceMetadata.attackVector).toBeDefined();
      expect(pkceMetadata.mitigation).toBeDefined();
      expect(pkceMetadata.demoScenario).toBeDefined();
    });
  });
});
